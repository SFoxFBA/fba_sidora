<?php

/**
 * Implements hook_islandora_xml_form_builder_forms().
 */
function fba_sidora_islandora_xml_form_builder_forms() {
  $form_path = drupal_get_path('module', 'fba_sidora') . '/fba/FBAforms';
  return array(
    'FBA Synthesis' => array('form_file' => "$form_path/FBASynthesisSubClassForm.xml",),
    'FBA Simulation' => array('form_file' => "$form_path/FBASimulationSubClassForm.xml",),
    'FBA Literature Review' => array('form_file' => "$form_path/FBALiteratureReviewSubClassForm.xml",),
    'FBA Measurement' => array('form_file' => "$form_path/FBAMeasurementSubClassForm.xml",),
    'FBA Analysis' => array('form_file' => "$form_path/FBAAnalysisSubClassForm.xml",),
    'FBA Dataset' => array('form_file' => "$form_path/FBADatasetClassForm.xml",),
    'FBA Activity' => array('form_file' => "$form_path/FBAActivityClassForm.xml",),
    'FBA Supplementary Media' => array('form_file' => "$form_path/FBASupplementaryMediaClassForm.xml",),
    'FBA Supplementary Generic' => array('form_file' => "$form_path/FBASupplementaryGenericClassForm.xml",),
    'FBA Vocab Pref Term' => array('form_file' => "$form_path/FBAVocabPrefTermForm.xml",),
    'FBA Vocab Non Pref Term' => array('form_file' => "$form_path/FBAVocabNonPrefTermForm.xml",),
    'FBA Geo Pref Term' => array('form_file' => "$form_path/FBAGeoPrefTermForm.xml",),
    'FBA Geo Non Pref Term' => array('form_file' => "$form_path/FBAGeoNonPrefTermForm.xml",),
  );
}

/**
 * Implements hook_islandora_xml_form_builder_form_associations().
 */
function fba_sidora_islandora_xml_form_builder_form_associations() {
  return array(
    'FBASynthesisSubClassForm' => array(
      'content_model' => 'fba:synthesis_cmodel',
      'form_name' => 'FBA Synthesis',
      'dsid' => 'DTCA',
      'title_field' => array('title'),
      'transform' => 'dtca_to_dc.xsl',
      'template' => FALSE,
    ),
    'FBASimulationSubClassForm' => array(
      'content_model' => 'fba:simulation_cmodel',
      'form_name' => 'FBA Simulation',
      'dsid' => 'DTCA',
      'title_field' => array('title'),
      'transform' => 'dtca_to_dc.xsl',
      'template' => FALSE,
    ),
    'FBALiteratureReviewSubClassForm' => array(
      'content_model' => 'fba:litreview_cmodel',
      'form_name' => 'FBA Literature Review',
      'dsid' => 'DTCA',
      'title_field' => array('title'),
      'transform' => 'dtca_to_dc.xsl',
      'template' => FALSE,
    ),
    'FBAMeasurementSubClassForm' => array(
      'content_model' => 'fba:measurement_cmodel',
      'form_name' => 'FBA Measurement',
      'dsid' => 'DTCA',
      'title_field' => array('title'),
      'transform' => 'dtca_to_dc.xsl',
      'template' => FALSE,
    ),
    'FBAAnalysisSubClassForm' => array(
      'content_model' => 'fba:analysis_cmodel',
      'form_name' => 'FBA Analysis',
      'dsid' => 'DTCA',
      'title_field' => array('title'),
      'transform' => 'dtca_to_dc.xsl',
      'template' => FALSE,
    ),
    'FBADatasetClassForm' => array(
      'content_model' => 'fba:dataset_cmodel',
      'form_name' => 'FBA Dataset',
      'dsid' => 'DTCA',
      'title_field' => array('title'),
      'transform' => 'dtca_to_dc.xsl',
      'template' => FALSE,
    ),
    'FBAActivityClassForm' => array(
      'content_model' => 'fba:activity_cmodel',
      'form_name' => 'FBA Activity',
      'dsid' => 'DTCA',
      'title_field' => array('title'),
      'transform' => 'dtca_to_dc.xsl',
      'template' => FALSE,
    ),
    'FBASupplementaryMediaClassForm' => array(
      'content_model' => 'fba:supp_basic_image_cmodel',
      'form_name' => 'FBA Supplementary Media',
      'dsid' => 'DTCA',
      'title_field' => array('title'),
      'transform' => 'dtca_to_dc.xsl',
      'template' => FALSE,
    ),
    'FBASupplementaryGenericClassFormTxt' => array(
      'content_model' => 'fba:supp_text_cmodel',
      'form_name' => 'FBA Supplementary Generic',
      'dsid' => 'DTCA',
      'title_field' => array('title'),
      'transform' => 'dtca_to_dc.xsl',
      'template' => FALSE,
    ),
    'FBASupplementaryGenericClassFormWord' => array(
      'content_model' => 'fba:supp_word_cmodel',
      'form_name' => 'FBA Supplementary Generic',
      'dsid' => 'DTCA',
      'title_field' => array('title'),
      'transform' => 'dtca_to_dc.xsl',
      'template' => FALSE,
    ),
    'FBASupplementaryGenericClassFormXls' => array(
      'content_model' => 'fba:supp_excel_cmodel',
      'form_name' => 'FBA Supplementary Generic',
      'dsid' => 'DTCA',
      'title_field' => array('title'),
      'transform' => 'dtca_to_dc.xsl',
      'template' => FALSE,
    ),
    'FBASupplementaryGenericClassFormPdf' => array(
      'content_model' => 'fba:supp_pdf_cmodel',
      'form_name' => 'FBA Supplementary Generic',
      'dsid' => 'DTCA',
      'title_field' => array('title'),
      'transform' => 'dtca_to_dc.xsl',
      'template' => FALSE,
    ),
    'FBAVocabPrefTermForm' => array(
      'content_model' => 'fba:vocabpref_CModel',
      'form_name' => 'FBA Vocab Pref Term',
      'dsid' => 'MADS',
      'title_field' => array('authority', 'topic'),
      'transform' => 'vocabpref_mads_to_dc.xsl',
      'template' => FALSE,
    ),
    'FBAVocabNonPrefTermForm' => array(
      'content_model' => 'fba:vocabnonpref_CModel',
      'form_name' => 'FBA Vocab Non Pref Term',
      'dsid' => 'MADS',
      'title_field' => array('variant', 'topic'),
      'transform' => 'vocabnonpref_mads_to_dc.xsl',
      'template' => FALSE,),
    'FBAGeoPrefTermForm' => array(
      'content_model' => 'fba:geopref_CModel',
      'form_name' => 'FBA Geo Pref Term',
      'dsid' => 'MADS',
      'title_field' => array('authority', 'topic'),
      'transform' => 'geopref_mads_to_dc.xsl',
      'template' => FALSE,),
    'FBAGeoNonPrefTermForm' => array(
      'content_model' => 'fba:geononpref_CModel',
      'form_name' => 'FBA Geo Non Pref Term',
      'dsid' => 'MADS',
      'title_field' => array('variant', 'topic'),
      'transform' => 'geononpref_mads_to_dc.xsl',
      'template' => FALSE,),
  );
}

/**
 * 
 * @param IslandoraTuque $connection
 * @return array
 */
function fba_sidora_islandora_required_objects(IslandoraTuque $connection) {
  $module_path = drupal_get_path('module', 'fba_sidora');
  //si:root
  // COLLECTION_POLICY Datastream.
  $siroot_datastreams[] = array('COLLECTION_POLICY', 'Collection policy', 'text/xml', "$module_path/fba/collection_policies/fba_sidora_collection_policy.xml");
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'si:root', 'Sidora Top-level Collection', $siroot_datastreams);
  //si:user-projects doing a straight reingest wipes out the existing rels-exts!
  //$createuserproject = FALSE; //default to safest mode
  //try {
  //$siupobj = $connection->repository->getObject('si:user-projects');
  //$createuserproject = FALSE;
  //}
  //catch (Exception $exc) {
  //This means that the object doesn't exist
//    $createuserproject = TRUE;
//  }
//  if ($createuserproject) {
//    $siup_datastreams[] = array('COLLECTION_POLICY', 'Collection policy', 'text/xml', "$module_path/fba/collection_policies/fba_sidora_collection_policy.xml");
//    $siup_relation[] = array('relationship' => 'hasModel', 'pid' => 'si:conceptCModel');
//    $objectstoingest[] = fba_sidora_create_content_model($connection, 'si:user-projects', 'Sidora User Collection', $siup_datastreams, $siup_relation);
//  }
  //fba:root

  $fbaroot_datastreams[] = array('COLLECTION_POLICY', 'Collection policy', 'text/xml', "$module_path/fba/collection_policies/fba_sidora_collection_policy.xml");
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'fba:root', 'FBA Sidora Top-level Collection', $fbaroot_datastreams);

  //fba:user-projects doing a straight reingest wipes out the existing rels-exts!

  $createfbauserproject = FALSE; //default to safest mode for now until above can be fixed
  /*  try {
    $siupobj = $connection->repository->getObject('fba:user-projects');
    $createfbauserproject = FALSE;
    }
    catch (Exception $exc) {
    //This means that the object doesn't exist
    $createfbauserproject = TRUE;
    } */
  if ($createfbauserproject) {
    $fbaup_datastreams[] = array('COLLECTION_POLICY', 'Collection policy', 'text/xml', "$module_path/fba/collection_policies/fba_sidora_collection_policy.xml");
    $fbaup_relation[] = array('relationship' => 'hasModel', 'pid' => 'si:conceptCModel');
    $objectstoingest[] = fba_sidora_create_content_model($connection, 'fba:user-projects', 'FBA Sidora User Collection', $fbaup_datastreams, $fbaup_relation);
  }
  // 'si:conceptCModel'
  $con_datastreams[] = array('EAC-CPF', 'EAC-CPF', 'text/xml', "$module_path/smithsonian/datastreams/conceptCModel/EAC-CPF.xml");
  $con_datastreams[] = array('ISLANDORACM', 'ISLANDORACM', 'text/xml', "$module_path/smithsonian/datastreams/conceptCModel/ISLANDORACM.xml");
  $con_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/POLICY.xml");
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'si:conceptCModel', 'Smithsonian Concept', $con_datastreams);
  //  'si:datasetCModel',
  $ds_datastreams[] = array('FGDC', 'FGDC', 'text/xml', "$module_path/smithsonian/datastreams/datasetCModel/ISLANDORACM.xml");
  $ds_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/POLICY.xml");
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'si:datasetCModel', 'Smithsonian Dataset Concept', $ds_datastreams);
  //  'si:resourceCModel',
  $res_datastreams[] = array('EAC-CPF', 'EAC-CPF', 'text/xml', "$module_path/smithsonian/datastreams/resourceCModel/EAC-CPF.xml");
  $res_datastreams[] = array('ISLANDORACM', 'ISLANDORACM', 'text/xml', "$module_path/smithsonian/datastreams/resourceCModel/ISLANDORACM.xml");
  $res_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/POLICY.xml");
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'si:resourceCModel', 'Smithsonian Resource', $res_datastreams);
  //  no files for the following yet 'si:codebookCModel',
  //  
  //  'fba:licence_cmodel',
  $lic_mod_datastreams[] = array('ISLANDORACM', 'ISLANDORACM', 'text/xml', "$module_path/fba/datastreams/licence_cmodel/ISLANDORACM.xml");
  $lic_mod_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/datastreams/licence_cmodel/POLICY.xml");
  $lic_mod_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/datastreams/licence_cmodel/COLLECTION_POLICY.xml");
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'fba:licence_cmodel', 'FBA Licence Resource', $lic_mod_datastreams);

  //  'fba:licence_collection',
  $lic_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/datastreams/licence_cmodel/POLICY.xml");
  $lic_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/collection_policies/fba_licence_collection_policy.xml");
  $lic_relation[] = array(
    'relationship' => 'isMemberOfCollection',
    'pid' => 'fba:root');
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'fba:licence_collection', 'FBA Licence Collection', $lic_datastreams, $lic_relation);

  //  'fbalicence:1',
  $lic1_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/datastreams/licence_cmodel/POLICY.xml");
  $lic1_datastreams[] = array('LICENCE', 'Licence', 'text/html', "$module_path/fba/includes/licence1.txt");
  $lic1_relation[] = array(
    'relationship' => 'isMemberOfCollection',
    'pid' => 'fba:licence_collection');
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'fbalicence:1', 'FBA Licence', $lic1_datastreams, $lic1_relation);

  //  'fbalicence:2',
  $lic2_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/datastreams/licence_cmodel/POLICY.xml");
  $lic2_datastreams[] = array('LICENCE', 'Licence', 'text/html', "$module_path/fba/includes/licence2.txt");
  $lic2_relation[] = array(
    'relationship' => 'isMemberOfCollection',
    'pid' => 'fba:licence_collection');
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'fbalicence:2', 'FBA Licence', $lic2_datastreams, $lic2_relation);

  //AEDA collections
  $aedac_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/anonymous_view_policy.xml");
  $aedac_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/collection_policies/aeda_collection_policy.xml");
  $aedac_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/collection_policies/TN.png"); //TODO Is this a duplicate
  $aedac_relation[] = array(
    'relationship' => 'isMemberOfCollection',
    'pid' => 'islandora:root');
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'aeda:collection', 'AEDA Collection', $aedac_datastreams, $aedac_relation);

  //AEDA collections
  $aest_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/anonymous_view_policy.xml");
  $aest_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/collection_policies/aest_collection_policy.xml");
  $aest_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/collection_policies/TN.png");
  $aest_relation[] = array(
    'relationship' => 'isMemberOfCollection',
    'pid' => 'aeda:collection');
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'aest:collection', 'Atlantic Salmon Trust Collection', $aest_datastreams, $aest_relation);

  $defra_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/anonymous_view_policy.xml");
  $defra_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/collection_policies/defra_collection_policy.xml");
  $defra_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/collection_policies/TN.png");
  $defra_relation[] = array(
    'relationship' => 'isMemberOfCollection',
    'pid' => 'aeda:collection');
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'defra:collection', 'DEFRA Collections', $defra_datastreams, $defra_relation);

  $ea_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/anonymous_view_policy.xml");
  $ea_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/collection_policies/ea_collection_policy.xml");
  $ea_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/collection_policies/TN.png");
  $ea_relation[] = array(
    'relationship' => 'isMemberOfCollection',
    'pid' => 'aeda:collection');
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'ea:collection', 'Environment Agency Collections', $ea_datastreams, $ea_relation);

  $fba_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/anonymous_view_policy.xml");
  $fba_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/collection_policies/fba_collection_policy.xml");
  $fba_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/collection_policies/TN.png");
  $fba_relation[] = array(
    'relationship' => 'isMemberOfCollection',
    'pid' => 'aeda:collection');
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'fba:collection', 'FBA Collections', $fba_datastreams, $fba_relation);
  //end of level 1 collections
  //start of defra subcollections
  $dtc_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/anonymous_view_policy.xml");
  $dtc_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/collection_policies/dtc_collection_policy.xml");
  $dtc_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/collection_policies/TN.png");
  $dtc_relation[] = array(
    'relationship' => 'isMemberOfCollection',
    'pid' => 'defra:collection');
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'dtc:collection', 'DTC Data', $dtc_datastreams, $dtc_relation);

  $ghgno_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/anonymous_view_policy.xml");
  $ghgno_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/collection_policies/ghg_collection_policy.xml");
  $ghgno_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/collection_policies/TN.png");
  $ghgno_relation[] = array(
    'relationship' => 'isMemberOfCollection',
    'pid' => 'defra:collection');
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'ghgno:collection', 'GHG Nitrous Oxide Data', $ghgno_datastreams, $ghgno_relation);

  $ghgemh_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/anonymous_view_policy.xml");
  $ghgemh_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/collection_policies/ghg_collection_policy.xml");
  $ghgemh_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/collection_policies/TN.png");
  $ghgemh_relation[] = array(
    'relationship' => 'isMemberOfCollection',
    'pid' => 'defra:collection');
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'ghgemh:collection', 'GHG Methane Data', $ghgemh_datastreams, $ghgemh_relation);

  $dtcavon_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/anonymous_view_policy.xml");
  $dtcavon_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/collection_policies/dtcavon_collection_policy.xml");
  $dtcavon_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/collection_policies/TN.png");
  $dtcavon_relation[] = array(
    'relationship' => 'isMemberOfCollection',
    'pid' => 'dtc:collection');
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'dtcavon:collection', 'Avon DTC', $dtcavon_datastreams, $dtcavon_relation);

  $dtceden_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/anonymous_view_policy.xml");
  $dtceden_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/collection_policies/dtceden_collection_policy.xml");
  $dtceden_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/collection_policies/TN.png");
  $dtceden_relation[] = array(
    'relationship' => 'isMemberOfCollection',
    'pid' => 'dtc:collection');
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'dtceden:collection', 'Eden DTC', $dtceden_datastreams, $dtceden_relation);

  $dtcwensum_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/anonymous_view_policy.xml");
  $dtcwensum_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/collection_policies/dtcwensum_collection_policy.xml");
  $dtcwensum_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/collection_policies/TN.png");
  $dtcwensum_relation[] = array(
    'relationship' => 'isMemberOfCollection',
    'pid' => 'dtc:collection');
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'dtcwensum:collection', 'Wensum DTC', $dtcwensum_datastreams, $dtcwensum_relation);

//ea collections
  $eachryso_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/anonymous_view_policy.xml");
  $eachryso_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/collection_policies/eachryso_collection_policy.xml");
  $eachryso_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/collection_policies/TN.png");
  $eachryso_relation[] = array(
    'relationship' => 'isMemberOfCollection',
    'pid' => 'ea:collection');
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'eachryso:collection', 'Chrysophytes Database', $eachryso_datastreams, $eachryso_relation);

  $ealit_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/anonymous_view_policy.xml");
  $ealit_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/collection_policies/ealit_collection_policy.xml");
  $ealit_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/collection_policies/TN.png");
  $ealit_relation[] = array(
    'relationship' => 'isMemberOfCollection',
    'pid' => 'ea:collection');
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'ealit:collection', 'Grey Literature', $ealit_datastreams, $ealit_relation);

//fba collections
  $fbads_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/anonymous_view_policy.xml");
  $fbads_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/collection_policies/fbads_collection_policy.xml");
  $fbads_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/collection_policies/TN.png");
  $fbads_relation[] = array(
    'relationship' => 'isMemberOfCollection',
    'pid' => 'fba:collection');
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'fbads:collection', 'Datasets', $fbads_datastreams, $fbads_relation);

  $fbaia_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/anonymous_view_policy.xml");
  $fbaia_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/collection_policies/fbaia_collection_policy.xml");
  $fbaia_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/collection_policies/TN.png");
  $fbaia_relation[] = array(
    'relationship' => 'isMemberOfCollection',
    'pid' => 'fba:collection');
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'fbaia:collection', 'FBA Image Archive', $fbaia_datastreams, $fbaia_relation);

  $fbalc_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/anonymous_view_policy.xml");
  $fbalc_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/collection_policies/fbalc_collection_policy.xml");
  $fbalc_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/collection_policies/TN.png");
  $fbalc_relation[] = array(
    'relationship' => 'isMemberOfCollection',
    'pid' => 'fba:collection');
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'fbalc:collection', 'Library Catalogue', $fbalc_datastreams, $fbalc_relation);

  $fbauc_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/anonymous_view_policy.xml");
  $fbauc_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/collection_policies/fbauc_collection_policy.xml");
  $fbauc_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/collection_policies/TN.png");
  $fbauc_relation[] = array(
    'relationship' => 'isMemberOfCollection',
    'pid' => 'fba:collection');
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'fbauc:collection', 'Unpublished Collections', $fbauc_datastreams, $fbauc_relation);

//Definition for each CModel at this level
//Next CModel - FBA from here on
  $fbaan_datastreams[] = array('ISLANDORACM', 'ISLANDORACM', 'text/xml', "$module_path/fba/datastreams/analysis_cmodel/ISLANDORACM.xml"); //TODO duplicated?
  $fbaan_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/POLICY.xml"); //TODO duplicated?
  $fbaan_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/datastreams/analysis_cmodel/COLLECTION_POLICY.xml");
  $fbaan_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/datastreams/analysis_cmodel/TN.png"); //TODO duplicated?
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'fba:analysis_cmodel', 'FBA Analysis Resource', $fbaan_datastreams, array(), FALSE); //FALSE stops ->models being defined which tags it as a concept for some reason
//Next Model
  $fbamt_datastreams[] = array('ISLANDORACM', 'ISLANDORACM', 'text/xml', "$module_path/fba/datastreams/measurement_cmodel/ISLANDORACM.xml"); //TODO duplicated?
  $fbamt_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/POLICY.xml"); //TODO duplicated?
  $fbamt_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/datastreams/measurement_cmodel/COLLECTION_POLICY.xml");
  $fbamt_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/datastreams/measurement_cmodel/TN.png"); //TODO duplicated?
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'fba:measurement_cmodel', 'FBA Measurement Resource', $fbamt_datastreams, array(), FALSE); //FALSE stops ->models being defined which tags it as a concept for some reason
//Next Model
  $fbalr_datastreams[] = array('ISLANDORACM', 'ISLANDORACM', 'text/xml', "$module_path/fba/datastreams/litreview_cmodel/ISLANDORACM.xml"); //TODO duplicated?
  $fbalr_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/POLICY.xml"); //TODO duplicated?
  $fbalr_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/datastreams/litreview_cmodel/COLLECTION_POLICY.xml");
  $fbalr_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/datastreams/litreview_cmodel/TN.png"); //TODO duplicated?
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'fba:litreview_cmodel', 'FBA Literature Review Resource', $fbalr_datastreams, array(), FALSE); //FALSE stops ->models being defined which tags it as a concept for some reason
//Next Model
  $fbasi_datastreams[] = array('ISLANDORACM', 'ISLANDORACM', 'text/xml', "$module_path/fba/datastreams/simulation_cmodel/ISLANDORACM.xml"); //TODO duplicated?
  $fbasi_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/POLICY.xml"); //TODO duplicated?
  $fbasi_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/datastreams/simulation_cmodel/COLLECTION_POLICY.xml");
  $fbasi_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/datastreams/simulation_cmodel/TN.png"); //TODO duplicated?
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'fba:simulation_cmodel', 'FBA Simulation Resource', $fbasi_datastreams, array(), FALSE); //FALSE stops ->models being defined which tags it as a concept for some reason
//Next Model
  $fbasy_datastreams[] = array('ISLANDORACM', 'ISLANDORACM', 'text/xml', "$module_path/fba/datastreams/synthesis_cmodel/ISLANDORACM.xml"); //TODO duplicated?
  $fbasy_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/POLICY.xml"); //TODO duplicated?
  $fbasy_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/datastreams/synthesis_cmodel/COLLECTION_POLICY.xml");
  $fbasy_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/datastreams/synthesis_cmodel/TN.png"); //TODO duplicated?
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'fba:synthesis_cmodel', 'FBA Synthesis Resource', $fbasy_datastreams, array(), FALSE); //FALSE stops ->models being defined which tags it as a concept for some reason
//Next Model (NB this is a concept)
  $fbaac_datastreams[] = array('ISLANDORACM', 'ISLANDORACM', 'text/xml', "$module_path/fba/datastreams/activity_cmodel/ISLANDORACM.xml"); //TODO duplicated?
  $fbaac_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/POLICY.xml"); //TODO duplicated?
  $fbaac_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/datastreams/activity_cmodel/COLLECTION_POLICY.xml");
  $fbaac_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/datastreams/activity_cmodel/TN.png"); //TODO duplicated?
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'fba:activity_cmodel', 'FBA Activity Concept', $fbaac_datastreams, array());
//Next Model (NB this is a concept)
  $fbadset_datastreams[] = array('ISLANDORACM', 'ISLANDORACM', 'text/xml', "$module_path/fba/datastreams/dataset_cmodel/ISLANDORACM.xml"); //TODO duplicated?
  $fbadset_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/POLICY.xml"); //TODO duplicated?
  $fbadset_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/datastreams/dataset_cmodel/COLLECTION_POLICY.xml");
  $fbadset_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/datastreams/dataset_cmodel/TN.png"); //TODO duplicated?
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'fba:dataset_cmodel', 'FBA Dataset Concept', $fbadset_datastreams, array());
//Next Model
  $fbasbi_datastreams[] = array('ISLANDORACM', 'ISLANDORACM', 'text/xml', "$module_path/fba/datastreams/image_cmodel/xml/supp_basic_image_cmodel.xml"); //TODO duplicated?
  $fbasbi_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/POLICY.xml"); //TODO duplicated?
  $fbasbi_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/datastreams/image_cmodel/xml/image_collection_policy.xml");
  $fbasbi_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/datastreams/image_cmodel/images/Crystal_Clear_filesystem_folder_grey.png"); //TODO duplicated?
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'fba:supp_basic_image_cmodel', 'FBA content model for basic image', $fbasbi_datastreams, array());
//Next Model
  $fbaspdf_datastreams[] = array('ISLANDORACM', 'ISLANDORACM', 'text/xml', "$module_path/fba/datastreams/pdf_cmodel/xml/supp_pdf_cmodel.xml"); //TODO duplicated?
  $fbaspdf_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/POLICY.xml"); //TODO duplicated?
  $fbaspdf_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/datastreams/pdf_cmodel/xml/pdf_collection_policy.xml");
  $fbaspdf_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/datastreams/pdf_cmodel/images/Crystal_Clear_mimetype_pdf.png"); //TODO duplicated?
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'fba:supp_pdf_cmodel', 'FBA content model for pdf', $fbaspdf_datastreams, array());
//Next Model
  $fbastxt_datastreams[] = array('ISLANDORACM', 'ISLANDORACM', 'text/xml', "$module_path/fba/datastreams/text_cmodel/xml/supp_text_cmodel.xml"); //TODO duplicated?
  $fbastxt_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/POLICY.xml"); //TODO duplicated?
  $fbastxt_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/datastreams/text_cmodel/xml/text_collection_policy.xml");
  $fbastxt_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/datastreams/text_cmodel/images/Crystal_Clear_mimetype_pdf.png"); //TODO duplicated?
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'fba:supp_text_cmodel', 'FBA content model for text file', $fbastxt_datastreams, array());
//Next Model
  $fbaswd_datastreams[] = array('ISLANDORACM', 'ISLANDORACM', 'text/xml', "$module_path/fba/datastreams/word_cmodel/xml/supp_word_cmodel.xml"); //TODO duplicated?
  $fbaswd_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/POLICY.xml"); //TODO duplicated?
  $fbaswd_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/datastreams/word_cmodel/xml/word_collection_policy.xml");
  $fbaswd_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/datastreams/word_cmodel/images/Crystal_Clear_mimetype_pdf.png"); //TODO duplicated?
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'fba:supp_word_cmodel', 'FBA content model for microsoft word file', $fbaswd_datastreams, array());
//Next Model
//Next Model
  $fbasxls_datastreams[] = array('ISLANDORACM', 'ISLANDORACM', 'text/xml', "$module_path/fba/datastreams/excel_cmodel/xml/supp_excel_cmodel.xml"); //TODO duplicated?
  $fbasxls_datastreams[] = array('POLICY', 'POLICY', 'text/xml', "$module_path/fba/security_policies/POLICY.xml"); //TODO duplicated?
  $fbasxls_datastreams[] = array('COLLECTION_POLICY', 'COLLECTION_POLICY', 'text/xml', "$module_path/fba/datastreams/excel_cmodel/xml/excel_collection_policy.xml");
  $fbasxls_datastreams[] = array('TN', 'thumbnail', 'image/png', "$module_path/fba/datastreams/excel_cmodel/images/Crystal_Clear_mimetype_pdf.png"); //TODO duplicated?
  $objectstoingest[] = fba_sidora_create_content_model($connection, 'fba:supp_excel_cmodel', 'FBA content model for microsoft excel file', $fbasxls_datastreams, array());
//End of definitions


  return array(
    'fba_sidora' => array(
      'title' => 'FBA Sidora Core',
      'objects' => $objectstoingest,
    ),
  );
}

function fba_sidora_create_content_model($connection, $pid, $label, $datastreams, $relationships = array(), $defineModels = TRUE) {
  $object = $connection->repository->constructObject($pid);
  $object->owner = 'fedoraAdmin';
  $object->label = $label;
  if ($defineModels) {
    $object->models = 'islandora:collectionCModel'; //In the php code, having this set means it's a concept.
  }


  foreach ($relationships as $relationship) {
    $object->relationships->add(FEDORA_RELS_EXT_URI, $relationship['relationship'], $relationship['pid']);
  }
  if (count($datastreams) > 0) {
    foreach ($datastreams as $datastreamvalues) {
      $mimetype = $datastreamvalues[2];
      if (strpos($mimetype, 'image/') !== FALSE) {
        $dstype = 'M';
      }
      else {
        $dstype = 'X';
      }
      $datastream = $object->constructDatastream($datastreamvalues[0], $dstype);
      $datastream->label = $datastreamvalues[1];
      $datastream->mimetype = $mimetype;
      $datastream->setContentFromFile($datastreamvalues[3], FALSE);
      $object->ingestDatastream($datastream);
    }
  }
  return $object;
}

/**
 *
 * Obtain the content-model-id of the object in order to
 * get the XML-Form and build the XML-Form to determine
 * whether there are any sparql-autocompletes attached.
 * Remove any links corresponding to this object that are
 * associated with other objects.
 *
 * @param string $pid 
 *   The PID of the object to be purged.
 * return
 *   None
 */
function process_links_on_purge($pid) {
  if (variable_get('rdf_relationships', NULL)) {
    // An unrelated rdf_relationships variable
    // is present that should be unset. This can happen
    // when a user loads up an XML-form but never clicks
    // on the submit button.
    variable_set('rdf_relationships', NULL);
  }
  $content_model_pid = get_object_linker_content_model($pid);
  if (strlen($content_model_pid) > 0) {
    $object_linker_form_name = get_object_linker_form_name($pid, $content_model_pid);
    if (strlen($object_linker_form_name) > 0) {
      // Build the form so that any link info
      // is stored in the rdf_relationships
      // variable.
      build_object_linker_form($object_linker_form_name);
      if (variable_get('rdf_relationships', NULL)) {
        // Set up the batch array for link removal batch processing.
        $progressMessage = 'Processed @current out of @total';
        $batch = array(
          'title' => t('Processing ...'),
          'file' => drupal_get_path('module', 'fba_sidora') . '/fba_sidora.module',
          'operations' => array(),
          'finished' => 'completeObjectLinkerBatchProcessing',
          'init_message' => t('Initializing... '),
          'progress_message' => t($progressMessage),
          'error_message' => t('An error was encountered while removing links.'),
        );
        remove_links_on_purge($batch, $pid);
        batch_set($batch);
        variable_set('rdf_relationships', NULL);
      }
    }
  }
}

/**
 *
 * Get the content model associated with the PID of the
 * object passed in as a parameter. If more than one
 * content model (that is not part of the core processing)
 * is associated with the object, output an error message
 * and return an empty string.
 *
 * @param string $pid
 *   The PID of the object for which the content
 *   model is to be found.
 * return string
 *   The PID of the content model or an empty string.
 */
function get_object_linker_content_model($pid) {
  module_load_include('inc', 'fedora_repository', 'api/fedora_utils');
  $spoSubject = '<info:fedora/' . $pid . '>';
  $spoPredicate = '<info:fedora/fedora-system:def/model#hasModel>';
  $spoObject = '*';
  $contentModels = spo_search($spoSubject, $spoPredicate, $spoObject);
  $contentModelsTot = count($contentModels);

  foreach ($contentModels as $contentModel) {
    switch ($contentModel['objectPid']) {
      case "fedora-system:FedoraObject-3.0":
      case "si:resourceCModel":
      case "si:conceptCModel":
      case "si:collectionCModel":
        $contentModelsTot -= 1;
        break;
      default:
        $objectLinkerContentModel = $contentModel['objectPid'];
    }
  }
  if ($contentModelsTot == 1) {
    return $objectLinkerContentModel;
  }
  else {
    $msg = $pid . ', has ' . $contentModelsTot . ' content models attached so the form name could not be determined and so any links created by the Object Linker cannot be processed.';
    drupal_set_message(t($msg), 'error');
    return '';
  }
}

/**
 *
 * Build the XML-form with the name passed as a parameter.
 * This ensures that the 'rdf_relationships' variable
 * is populated with the configuration info present in the
 * RDF-autocomplete entries associated with the XML-form.
 *
 * @param string $formName
 *   The XML-form name to be built.
 *  
 * return
 *   None
 */
function build_object_linker_form($formName) {
  module_load_include('inc', 'xml_form_builder', 'XMLFormDatabase');
  module_load_include('inc', 'xml_form_api', 'XMLForm');
  module_load_include('inc', 'xml_form_api', 'XMLFormDefinition');

  $formState = array();
  $form = array();

  try {
    $objectLinkerXmlForm = new XMLForm($formState);
    if (!$objectLinkerXmlForm->isInitialized()) {
      // Load up the form in order to populate the
      // rdf_relationships variable for the form.

      $object_linker_form = xml_form_builder_get_form($form, $formState, $formName);
//      $object_linker_definition = new XMLFormDefinition(XMLFormDatabase::Get($formName));
//      $object_linker_form = $object_linker_definition->getForm();

      unset($objectLinkerXmlForm);
//      unset($object_linker_definition);
      unset($object_linker_form);
      unset($formState);
    }
  }
  catch (Exception $e) {
    $msg = "File: {$e->getFile()}<br/>Line: {$e->getLine()}<br/>Error: {$e->getMessage()}";
    drupal_set_message(filter_xss(t($msg)), 'error');
  }
}

/**
 *
 * Remove any inverse RDF-links and symmetric entries in the
 * datastreams of linked objects.
 *
 * @param array $batch 
 *   The array that controls the batch processing for link removal
 * @param string $subjectPid 
 *   The PID of the object that is being purged.
 * return
 *   None
 */
function remove_links_on_purge(&$batch, $subjectPid) {
  module_load_include('inc', 'fedora_repository', 'api/tuque');
  module_load_include('inc', 'islandora_autocomplete_sparql', 'includes/islandora_autocomplete_sparql.vocab');
  $aggregateTriplesTot = 0;
  $linkTypeOutwardOnly = 0;
  $linkTypeOutwardAndInverse = 1;
  //$linkTypeInverseOnly = 2;
  $linkTypeLiteral = 3;

  $rdf_relationships = variable_get('rdf_relationships', NULL);
  //variable_set('rdf_relationships', NULL); Do not set this to null here because batch purge reuses this variable when multiple objects have the same form.
  $subject = islandora_object_load($subjectPid);

  if ($subject) {
    //Get the dc.title value for the subject incase it is required
    //for removing inverse symmetric data in the object datastreams.

    $subjectDCTitle = get_datastream_content_via_xpath_local($subject, 'DC', PURL_ELEMENTS_URI, '/oai_dc:dc/dc:title');
    foreach ($rdf_relationships as $rdf_relationship) {
      // A $linkTypeLiteral rdf will be removed from the
      // triple-store as part of the standard purge
      // processing so no action needs to be taken.
      if ($rdf_relationship['link_type'] != $linkTypeLiteral) {
        // The outward rdf links do not need to be removed
        // because they will be deleted from the triple-store 
        // as part of the standard fedora processing on purge.
        if ($rdf_relationship['link_type'] == $linkTypeOutwardOnly || $rdf_relationship['link_type'] == $linkTypeOutwardAndInverse) {
          // Store all the RDF-info relating to the outward
          // links for the current relationship in an array
          // so that the inverse links and any symmetric
          // datastream content in the linked-to object can
          // be removed.
          $spoSubject = '<info:fedora/' . $subjectPid . '>';
          $spoPredicate = '<' . $rdf_relationship['rdf_predicate'] . '>';
          $spoObject = '*';
          $objectTriplesForRelationship = spo_search($spoSubject, $spoPredicate, $spoObject);
          $objectTriplesForRelationshipTot = count($objectTriplesForRelationship);
          $aggregateTriplesTot += $objectTriplesForRelationshipTot;
          if ($objectTriplesForRelationshipTot > 0) {
            if ($rdf_relationship['link_type'] == $linkTypeOutwardAndInverse) {
              $inverseName = fba_textfield_inverseof_value($rdf_relationship['rdf_predicate']);
              if (!strcmp($inverseName, 'No inverse')) {
                $rdfName = ''; //SFOX Uninitialised variables
                $objectPid = ''; //SFOX Uninitialised variables
                $msg = 'While purging "' . $subjectDCTitle . '" with ID "' . $subjectPid . '" and attempting to remove the inverse link for "' . $rdfName . '" on the object "' . $objectPid . '", the inverse linkname was not found in the ontology.';
                drupal_set_message(t($msg));
              }
            }
            list($rdfNamespace, $rdfName) = fba_rdfx_split_uri($rdf_relationship['rdf_predicate']);
            foreach ($objectTriplesForRelationship as $objectTripleForRelationship) {
              $objectPid = $objectTripleForRelationship['objectPid'];
              remove_inverse_rdf_batch($subjectPid, $objectPid, $rdf_relationship, $rdfNamespace, $inverseName, $subjectDCTitle);
            }
          }
        }
        else {
          // This must be an inverse-only type of link.
          $inversePredicate = fba_textfield_inverseof_predicate($rdf_relationship['rdf_predicate']);
          $inverseError = false;
          if (strcmp($inversePredicate, 'No inverse predicate')) {
            list($inverseNamespace, $inverseName) = fba_rdfx_split_uri($inversePredicate);
            if (strlen($inverseName) == 0) {
              $inverseError = true;
            }
          }
          else {
            $inverseError = true;
          }
          if ($inverseError) {
            $msgInsert = $subjectDCTitle;
            $msg = 'While creating or editing "' . $msgInsert . '" with ID "' . $subjectPid . '" and attempting to create an inverse of the "' . $rdfName . '" link, the inverse was not found.';
            drupal_set_message(t($msg));
            break;
          }

          $spoSubject = '*';
          $spoPredicate = '<' . $inversePredicate . '>';
          $spoObject = '<info:fedora/' . $subjectPid . '>';
          $objectTriplesForRelationship = spo_search($spoSubject, $spoPredicate, $spoObject);
          $objectTriplesForRelationshipTot = count($objectTriplesForRelationship);
          $aggregateTriplesTot += $objectTriplesForRelationshipTot;
          if ($objectTriplesForRelationshipTot > 0) {
            foreach ($objectTriplesForRelationship as $objectTripleForRelationship) {
              $objectPid = $objectTripleForRelationship['subjectPid'];
              remove_inverse_rdf_batch($subjectPid, $objectPid, $rdf_relationship, $inverseNamespace, $inverseName, $subjectDCTitle);
            }
          }
        }
      }
    }
    // The processing above should cover normal eventualities, however
    // it is possible that inverse links would remain if, for example,
    // the sparql autocomplete records were modified after objects with
    // related links had been created. The systems administrator should 
    // not have let this situation arise, but we should remove them if
    // they exist. As the links will still exist until the batch
    // operations are executed a check is made to establish whether
    // more links exist than have already been accounted for and the
    // extra batch operation below is only called if there are more.
    // Note that what is referred to as a "subject" within the
    // spo_search and triple, is different from the main "subject" of
    // this purge, because the main "subject" is used as the "object"
    // within the spo_search.
    // The first instance of $rdf_relationships[0] is passed to the
    // function because a parameter and this is as good an arbitrary
    // choice as any because this processing is a catch-all independent
    // of the content of the $rdf_relationships array. If it happens
    // to result in a datastream entry being removed then that is a
    // bonus.
    $spoSubject = '*';
    $spoPredicate = '*';
    $spoObject = '<info:fedora/' . $subjectPid . '>';
    $triples = spo_search($spoSubject, $spoPredicate, $spoObject);
    $triplesTot = count($triples);
    if ($triplesTot > 0 && $triplesTot > $aggregateTriplesTot) {
      foreach ($triples as $triple) {
        list($rdfNamespace, $rdfName) = fba_rdfx_split_uri($triple['predicate']);
        $objectPid = $triple['subjectPid'];
        remove_inverse_rdf_batch($subjectPid, $objectPid, $rdf_relationships[0], $rdfNamespace, $rdfName, $subjectDCTitle);
      }
    }
  }
}

/**
 * Searches for data in the datastream provided which matches
 * the Object Linking info relating to one or more RDF-autocomplete
 * entries associated with the XML-form that have been configured
 * in the sparql submodule.
 * It strips out any object-PIDs so that they are not stored in
 * the datastream and stores the relevant info in the 'rdf_relationships'
 * variable.
 *
 * @param DOMDocument $definition
 *   The Datastream XML that may contain data to trigger RDF linking.
 * @return
 *   None
 */
function preprocess_link_data(DOMDocument &$document) {
  $namespacePrefixesRegistered = array();
  $checkPreviousNamespacePrefixes = true;
  $pidDelim = '||';
  $rdfRelationshipCount = 0;
  $charsInDelim = 2;
  $rdf_relationships = variable_get('rdf_relationships', NULL);
  $domxpath = new domXpath($document);
  foreach ($rdf_relationships as $rdf_relationship) {
    $subjectXpathDataSearch = $rdf_relationship['subject_xpath_data_search'];
    if (strlen($subjectXpathDataSearch) > 0) {
      register_xpath_namespaces($domxpath, $rdf_relationship['subject_namespace_info'], $checkPreviousNamespacePrefixes, $namespacePrefixesRegistered);
      $queryResults = $domxpath->query($subjectXpathDataSearch);
      $queryResultCount = 0;
      if ($queryResults->length > 0) {
        foreach ($queryResults as $queryResult) {
          $objectPidFound = 0;
          $objectItem = $queryResult->textContent;
          if ($rdf_relationship['object_pid_append_required']) {
            $objectPid = strstr($objectItem, $pidDelim);
            if (strlen($objectPid) > $charsInDelim) {
              $objectPid = substr($objectPid, $charsInDelim);
              $delimPos = strpos($objectPid, $pidDelim);
              if ($delimPos !== false) {
                $objectPid = substr($objectPid, 0, $delimPos);
                if (strlen($objectPid) > 0) {
                  $objectPidFound = 1;
                  $dataMinusPid = substr($objectItem, 0, strlen($objectItem) - (strlen($objectPid) + (2 * $charsInDelim) + 1));
                  $rdf_relationships[$rdfRelationshipCount]['rdf_link'][]['pid'] = $objectPid;
                  $rdf_relationships[$rdfRelationshipCount]['rdf_link'][$queryResultCount]['data'] = $dataMinusPid;
                  $queryResult->nodeValue = $dataMinusPid;
                  //$dataMinusPid needs writing back into $document too!!!
                }
              }
            }
          }
          if (!$objectPidFound) {
            $rdf_relationships[$rdfRelationshipCount]['rdf_link'][]['pid'] = 'nopid';
            $rdf_relationships[$rdfRelationshipCount]['rdf_link'][$queryResultCount]['data'] = $objectItem;
          }
          $queryResultCount += 1;
        }
      }
      $rdfRelationshipCount += 1;
    }
  }
  variable_set('rdf_relationships', $rdf_relationships);
}

/**
 * Processes the configuration info in the 'rdf_relationships' variable,
 * which relates to one or more RDF-autocomplete entries in the MySQL
 * database that are associated with the XML-Form.
 * RDF-links and inverse-links are created/removed from subject and object
 * where appropriate. The relevant datastreams in the objects are updated
 * with symmetrical entries, where appropriate.
 *
 * @param array $form
 *   The data relating to the XML-form that has been submitted.
 * @param array $form_state
 *   Contains the PID of the object that possesses the datastream
 *   that populated the XML-Form.
 * @param boolean $editFlag
 *   Indicates whether processing the ingest of an object (FALSE)
 *   or the edit of an existing object (TRUE)
 * @return
 *   None
 */
function preprocess_links(&$form, &$form_state, $editFlag, $pid) {
  module_load_include('inc', 'fedora_repository', 'api/tuque');
  module_load_include('inc', 'islandora_autocomplete_sparql', 'includes/islandora_autocomplete_sparql.vocab');

  $relations = NULL;
  $replaceSubjectTitleInObjectDatastream = false;
  $preEditSubjectTitle = '';
  $postEditSubjectTitle = '';
  $linkTypeOutwardOnly = 0;
  $linkTypeOutwardAndInverse = 1;
  $linkTypeInverseOnly = 2;
  $linkTypeLiteral = 3;
  // Check whether any autocomplete entries that involve rdf-linking
  // were found while the xml-form was being built.  
  if (variable_get('rdf_relationships', NULL)) {
    $rdf_relationships = variable_get('rdf_relationships', NULL);
    variable_set('rdf_relationships', NULL);

    // Process through the relationship-configuration entries
    // associated with the xml-form and take the appropriate
    // action.
    $rdfRelationshipCount = 0;
    foreach ($rdf_relationships as $rdf_relationship) {
      list($rdfNamespace, $rdfName) = fba_rdfx_split_uri($rdf_relationship['rdf_predicate']);
      $rdfRelationshipCount += 1;
      if ($rdf_relationship['link_type'] == $linkTypeOutwardAndInverse || $rdf_relationship['link_type'] == $linkTypeInverseOnly) {
        $inversePredicate = fba_textfield_inverseof_predicate($rdf_relationship['rdf_predicate']);
        $inverseError = false;
        if (strcmp($inversePredicate, 'No inverse predicate')) {
          list($notused, $inverseName) = fba_rdfx_split_uri($inversePredicate);
          if (strlen($inverseName) == 0) {
            $inverseError = true;
          }
        }
        else {
          $inverseError = true;
        }
        if ($inverseError) {
          if ($editFlag) {
            $msgInsert = $postEditSubjectTitle;
          }
          else {
            $msgInsert = $subjectDCTitle;
          }
          $msg = 'While creating or editing "' . $msgInsert . '" with ID "' . $pid . '" and attempting to create an inverse of the "' . $rdfName . '" link, the inverse was not found.';
          drupal_set_message(t($msg));
          break;
        }
      }
      if ($editFlag) {
        if ($rdfRelationshipCount == 1) {
          // Get the pre and post edit title values of
          // the subject-object. Only needs to be done once.
          if (strlen($rdf_relationship['subject_xpath_title_search']) > 0) {
            $titleArray = get_pre_and_post_edit_subject_titles_from_form($form, $rdf_relationship['subject_xpath_title_search']);
            if (count($titleArray) == 2) {
              $preEditSubjectTitle = $titleArray[0];
              $postEditSubjectTitle = $titleArray[1];
              // If the title has been modified, the new title should
              // replace the old title in the object-object where any
              // existing datastream symmetry is involved for this
              // relationship or any other relationship associated with
              // this form.
              if (strlen($preEditSubjectTitle) > 0) {
                if (strcmp($postEditSubjectTitle, $preEditSubjectTitle)) {
                  $replaceSubjectTitleInObjectDatastream = true;
                }
              }
            }
            else {
              $msg = 'While processing "' . $subjectDCTitle . '" with ID "' . $pid . '" the path corresponding to the "Subject XPath Title Search" field in the autocomplete record for the "' . $rdfName . '" link was not found.';
              drupal_set_message(t($msg));
            }
          }
          else {
            $msg = 'While processing "' . $subjectDCTitle . '" with ID "' . $pid . '" the "Subject Title XPath Search" field in the autocomplete recordfor the "' . $rdfName . '" link was found to be empty.';
            drupal_set_message(t($msg));
          }
        }
        // Store all the existing RDFs relating to this relationship
        // in an array.
        if ($rdf_relationship['link_type'] == $linkTypeOutwardOnly || $rdf_relationship['link_type'] == $linkTypeOutwardAndInverse || $rdf_relationship['link_type'] == $linkTypeLiteral) {
          $spoSubject = '<info:fedora/' . $pid . '>';
          $spoPredicate = '<' . $rdf_relationship['rdf_predicate'] . '>';
          $spoObject = '*';
        }
        else {
          // It must be an inverse-only type of link.
          $spoSubject = '*';
          $spoPredicate = '<' . $inversePredicate . '>';
          $spoObject = '<info:fedora/' . $pid . '>';
        }
        $preEditObjectTriplesForRelationship = spo_search($spoSubject, $spoPredicate, $spoObject);
      }
      //$rdfRelationshipRdfLinkCount = 0;
      if (array_key_exists('rdf_link', $rdf_relationship)) {
        $rdfRelationshipRdfLinkTot = count($rdf_relationship['rdf_link']);
      }
      else {
        $rdfRelationshipRdfLinkTot = 0;
      }
      if ($rdfRelationshipRdfLinkTot > 0) {
        $relations = preprocess_instances_of_this_relationship($form_state, $batch, $rdf_relationship, $editFlag, $userCollection, $preEditObjectTriplesForRelationship, $replaceSubjectTitleInObjectDatastream, $pid, $subject, $subjectDCTitle, $preEditSubjectTitle, $postEditSubjectTitle, $rdfName, $inverseName, $rdfNamespace, $inversePredicate, $linkTypeOutwardOnly, $linkTypeOutwardAndInverse, $linkTypeInverseOnly, $linkTypeLiteral);
        // object then subject relations to be created.
      }
      if ($editFlag) {
        if ($preEditObjectTriplesForRelationship) {
          foreach ($preEditObjectTriplesForRelationship as $preEditObjectTripleForRelationship) {
            process_edit_batch($rdf_relationship, $rdfRelationshipRdfLinkTot, $pid, $rdfName, $rdfNamespace, $inverseName, $inversePredicate, $preEditObjectTripleForRelationship, $replaceSubjectTitleInObjectDatastream, $preEditSubjectTitle, $postEditSubjectTitle, $linkTypeOutwardOnly, $linkTypeOutwardAndInverse, $linkTypeInverseOnly, $linkTypeLiteral);
          }
        }
      }
    }
  }
  variable_set('rdf_relationships', $rdf_relationships); //SFOX so the values are available for the process_links function

  return $relations;         // object then subject relations to be created. SFOX IS THIS USED?
}

/**
 * Processes the configuration info in the 'rdf_relationships' variable,
 * which relates to one or more RDF-autocomplete entries in the MySQL
 * database that are associated with the XML-Form.
 * RDF-links and inverse-links are created/removed from subject and object
 * where appropriate. The relevant datastreams in the objects are updated
 * with symmetrical entries, where appropriate.
 *
 * @param array $form
 *   The data relating to the XML-form that has been submitted.
 * @param array $form_state
 *   Contains the PID of the object that possesses the datastream
 *   that populated the XML-Form.
 * @param boolean $editFlag
 *   Indicates whether processing the ingest of an object (FALSE)
 *   or the edit of an existing object (TRUE)
 * @return
 *   None
 */
function process_links(&$form, &$form_state, $editFlag, $pid) {
  module_load_include('inc', 'fedora_repository', 'api/tuque');
  module_load_include('inc', 'islandora_autocomplete_sparql', 'includes/islandora_autocomplete_sparql.vocab');

  $replaceSubjectTitleInObjectDatastream = false;
  $preEditSubjectTitle = '';
  $postEditSubjectTitle = '';
  $linkTypeOutwardOnly = 0;
  $linkTypeOutwardAndInverse = 1;
  $linkTypeInverseOnly = 2;
  $linkTypeLiteral = 3;
  global $user;

  // Check whether any autocomplete entries that involve rdf-linking
  // were found while the xml-form was being built.  
  if (variable_get('rdf_relationships', NULL)) {
    $rdf_relationships = variable_get('rdf_relationships', NULL);
    variable_set('rdf_relationships', NULL);

    $subject = islandora_object_load($pid);
    if ($subject) {
      // Get the dc.title value for the subject-object.
      // It would be preferable to call the generic
      // function get_datastream_content_via_xpath()
      // in the fba_utility module, but this would
      // involve a second call to islandora_object_load
      // which would be an unnecessary performance hit,
      // so a local version of the function is used instead.
      $subjectDCTitle = get_datastream_content_via_xpath_local($subject, 'DC', PURL_ELEMENTS_URI, '/oai_dc:dc/dc:title');
      $rdfRelationshipCount = 0;

      // For dataset processing, construct the user collection.
      // This is effectively ignored for non-dataset processing.
      $userId = $user->data['islandora_user_pid'];
      if (strlen($userId) > 0) {
        $userCollectionNs = str_replace(array('-', ':'), '', $userId);
        $userCollection = $userCollectionNs . ':collection';
      }

      // Set up the batch array for ingest and update batch processing.
      /*
        $progressMessage = 'Processed @current out of @total';
        $batch = array(
        'title' => t('Processing ...'),
        'file' => drupal_get_path('module', 'fba_sidora') . '/fba_sidora.module',
        'operations' => array(),
        'finished' => 'completeObjectLinkerBatchProcessing',
        'init_message' => t('Initializing... '),
        'progress_message' => t($progressMessage),
        'error_message' => t('An error was encountered while processing links.'),
        );
       * 
       */

      // Process through the relationship-configuration entries
      // associated with the xml-form and take the appropriate
      // action.
      foreach ($rdf_relationships as $rdf_relationship) {
        list($rdfNamespace, $rdfName) = fba_rdfx_split_uri($rdf_relationship['rdf_predicate']);
        $rdfRelationshipCount += 1;
        if ($rdf_relationship['link_type'] == $linkTypeOutwardAndInverse || $rdf_relationship['link_type'] == $linkTypeInverseOnly) {
          $inversePredicate = fba_textfield_inverseof_predicate($rdf_relationship['rdf_predicate']);
          $inverseError = false;
          if (strcmp($inversePredicate, 'No inverse predicate')) {
            list($notused, $inverseName) = fba_rdfx_split_uri($inversePredicate);
            if (strlen($inverseName) == 0) {
              $inverseError = true;
            }
          }
          else {
            $inverseError = true;
          }
          if ($inverseError) {
            if ($editFlag) {
              $msgInsert = $postEditSubjectTitle;
            }
            else {
              $msgInsert = $subjectDCTitle;
            }
            $msg = 'While creating or editing "' . $msgInsert . '" with ID "' . $pid . '" and attempting to create an inverse of the "' . $rdfName . '" link, the inverse was not found.';
            drupal_set_message(t($msg));
            break;
          }
        }
        if ($editFlag) {
          if ($rdfRelationshipCount == 1) {
            // Get the pre and post edit title values of
            // the subject-object. Only needs to be done once.
            if (strlen($rdf_relationship['subject_xpath_title_search']) > 0) {
              $titleArray = get_pre_and_post_edit_subject_titles_from_form($form, $rdf_relationship['subject_xpath_title_search']);
              if (count($titleArray) == 2) {
                $preEditSubjectTitle = $titleArray[0];
                $postEditSubjectTitle = $titleArray[1];
                // If the title has been modified, the new title should
                // replace the old title in the object-object where any
                // existing datastream symmetry is involved for this
                // relationship or any other relationship associated with
                // this form.
                if (strlen($preEditSubjectTitle) > 0) {
                  if (strcmp($postEditSubjectTitle, $preEditSubjectTitle)) {
                    $replaceSubjectTitleInObjectDatastream = true;
                  }
                }
              }
              else {
                $msg = 'While processing "' . $subjectDCTitle . '" with ID "' . $pid . '" the path corresponding to the "Subject XPath Title Search" field in the autocomplete record for the "' . $rdfName . '" link was not found.';
                drupal_set_message(t($msg));
              }
            }
            else {
              $msg = 'While processing "' . $subjectDCTitle . '" with ID "' . $pid . '" the "Subject Title XPath Search" field in the autocomplete recordfor the "' . $rdfName . '" link was found to be empty.';
              drupal_set_message(t($msg));
            }
          }
          // Store all the existing RDFs relating to this relationship
          // in an array.
          if ($rdf_relationship['link_type'] == $linkTypeOutwardOnly || $rdf_relationship['link_type'] == $linkTypeOutwardAndInverse || $rdf_relationship['link_type'] == $linkTypeLiteral) {
            $spoSubject = '<info:fedora/' . $pid . '>';
            $spoPredicate = '<' . $rdf_relationship['rdf_predicate'] . '>';
            $spoObject = '*';
          }
          else {
            // It must be an inverse-only type of link.
            $spoSubject = '*';
            $spoPredicate = '<' . $inversePredicate . '>';
            $spoObject = '<info:fedora/' . $pid . '>';
          }
          $preEditObjectTriplesForRelationship = spo_search($spoSubject, $spoPredicate, $spoObject);
        }
        //$rdfRelationshipRdfLinkCount = 0;
        if (array_key_exists('rdf_link', $rdf_relationship)) {
          $rdfRelationshipRdfLinkTot = count($rdf_relationship['rdf_link']);
        }
        else {
          $rdfRelationshipRdfLinkTot = 0;
        }
        if ($rdfRelationshipRdfLinkTot > 0) {
          process_instances_of_this_relationship($batch, $rdf_relationship, $editFlag, $userCollection, $preEditObjectTriplesForRelationship, $replaceSubjectTitleInObjectDatastream, $pid, $subject, $subjectDCTitle, $preEditSubjectTitle, $postEditSubjectTitle, $rdfName, $inverseName, $rdfNamespace, $inversePredicate, $linkTypeOutwardOnly, $linkTypeOutwardAndInverse, $linkTypeInverseOnly, $linkTypeLiteral);
        }
        if ($editFlag) {
          if ($preEditObjectTriplesForRelationship) {
            foreach ($preEditObjectTriplesForRelationship as $preEditObjectTripleForRelationship) {
              //$batch['operations'][] = array('process_edit_batch', array($rdf_relationship, $rdfRelationshipRdfLinkTot, $pid, $rdfName, $rdfNamespace, $inverseName, $inversePredicate, $preEditObjectTripleForRelationship, $replaceSubjectTitleInObjectDatastream, $preEditSubjectTitle, $postEditSubjectTitle, $linkTypeOutwardOnly, $linkTypeOutwardAndInverse, $linkTypeInverseOnly, $linkTypeLiteral));
              process_edit_batch($rdf_relationship, $rdfRelationshipRdfLinkTot, $pid, $rdfName, $rdfNamespace, $inverseName, $inversePredicate, $preEditObjectTripleForRelationship, $replaceSubjectTitleInObjectDatastream, $preEditSubjectTitle, $postEditSubjectTitle, $linkTypeOutwardOnly, $linkTypeOutwardAndInverse, $linkTypeInverseOnly, $linkTypeLiteral);
            }
          }
        }
      }
      //batch_set($batch);
    }
    else {
      $msg = 'While processing the linking for a record with ID "' . $pid . '" the subject-object failed to load.';
      drupal_set_message(t($msg));
    }
  }
}

/**
 * Processes RDF-links and datastream modifications corresponding
 * to specific entries in the subject-object datastream.
 *
 * @param array $batch
 *   The array that controls batch processing
 * @param array $rdf_relationship
 *   Corresponds to a single RDF-autocomplete associated with an XML-form.
 * @param boolean $editFlag
 *   Indicates whether the subject-object is being edited.
 * @param string  $userCollection
 *   The identifier for the user in dataset processing. Not
 *   used for non-dataset processing.
 * @param array   $preEditObjectTriplesForRelationship
 *   The RDF links that were present previous to the user edit.
 * @param boolean $replaceSubjectTitleInObjectDatastream
 *   Flag to indicate that a change to the subject-object title
 *   necessitates an update to that string where it appears
 *   in an object-object datastream.
 * @param string $subjectPid
 *   The Persistent Identifier of the subject-object in the RDF
 * @param array  $subject
 *   The loaded subject-object
 * @param string $subjectDCTitle
 *   Contains the title of the subject for a newly ingested
 *   subject-object
 * @param string $preEditSubjectTitle
 *   If the user has edited an existing subject-object this
 *   contains the title of the subject-object prior
 *   to the XML form having been edited by the user.
 * @param string $postEditSubjectTitle
 *   If the user has edited an existing subject-object this
 *   contains the title of the subject object after
 *   the XML form has been edited by the user.
 * @param string $rdfName
 *   The verb of the predicate component in the RDF
 * @param string $inverseName
 *   The verb of the predicate component in the inverse RDF
 * @param string $rdfNamespace
 *   The stem of the predicate component in the RDF
 * @param string $inversePredicate
 *   The inverse of the predicate associated with the subject-object
 * @param int $linkTypeOutwardOnly
 *   Constant for link type that is subject to object only
 * @param int $linkTypeOutwardAndInverse
 *   Constant for link type that is subject to object and object to subject
 * @param int $linkTypeInverseOnly
 *   Constant for link type that is object to subject only
 * @param int $linkTypeLiteral
 *   Constant for link type that is subject only
 * return
 *   None
 */
function preprocess_instances_of_this_relationship(&$form_state, &$batch, &$rdf_relationship, &$editFlag, &$userCollection, &$preEditObjectTriplesForRelationship, &$replaceSubjectTitleInObjectDatastream, &$subjectPid, &$subject, &$subjectDCTitle, &$preEditSubjectTitle, &$postEditSubjectTitle, &$rdfName, &$inverseName, &$rdfNamespace, &$inversePredicate, &$linkTypeOutwardOnly, &$linkTypeOutwardAndInverse, &$linkTypeInverseOnly, &$linkTypeLiteral) {
  module_load_include('inc', 'fedora_repository', 'api/tuque');
  module_load_include('inc', 'fedora_repository', 'ObjectHelper');
  module_load_include('inc', 'fedora_repository', 'api/fedora_item');

  module_load_include('inc', 'islandora', 'includes/ingest.form');
  $newobject = NULL;

  $userCollectionPlaceHolder = 'user_collection_place_holder';
  $searchTermPlaceHolder = 'search_term_place_holder';
  $subjectPidPlaceHolder = 'subject_pid_place_holder';
  $rdfRelationshipRdfLinkCount = 0;
  foreach ($rdf_relationship['rdf_link'] as $link) {
    // If it is a literal type, we only need to check whether
    // an identical link and content already exist. However,
    // for all other types, if the user selected data from the 
    // autocomplete list, and object_pid_append_required is set,
    // there should be an object-pid associated with it.
    // However, it may not have been set or, even if it was set,
    // the user may have typed in some data and this data might
    // correspond to the title of an existing object, so check
    // if such an object exists and obtain its PID if it does,
    // so that an RDF link can be created to it.
    // If no existing object exists, but the autocomplete has been
    // set up such that the object should be created in such a
    // scenario, then create the object so that an RDF link
    // from the subject-object can be created to it.
    if ((strcmp($link['pid'], 'nopid') === 0) && strlen($link['data']) > 0) {
      // Construct a sparql query to check for the exitence of
      // the object.
      if ($rdf_relationship['object_creation_required']) {
        // As object creation is required, the sparql query is
        // constructed from the criteria specified in the relevant 
        // fields of the autocomplete record, e.g. the Object
        // Content Model and Collection Pids.
        $sparqlTestObjectExistence = sprintf('SELECT ?title ?object FROM <info:edu.si.fedora#ri> WHERE { ?object <%stitle> ?title; <fedora-model:hasModel> <info:fedora/%s>; <fedora-rels-ext:isMemberOfCollection> <info:fedora/%s> FILTER (regex(str(?title), "^%s$", "i"))}', PURL_ELEMENTS_URI, $rdf_relationship['object_content_model_pid'], $rdf_relationship['object_collection_pid'], escape_for_sparql($link['data']));
      }
      else {
        // As object creation is not required, the sparql query
        // that is used for the auto-complete is used instead
        // as this allows for greater flexibility.
        $sparqlTestObjectExistence = $rdf_relationship['sparql_field'];

        if (strpos($sparqlTestObjectExistence, $searchTermPlaceHolder)) {
          // Substitute the data for the search term place holder and
          // add a dollar sign so that an exact match is specified.
          $linkDataPlusDollar = escape_for_sparql($link['data']) . '$';
          $sparqlTestObjectExistence = str_replace($searchTermPlaceHolder, $linkDataPlusDollar, $sparqlTestObjectExistence);
        }
        if ($rdf_relationship['link_type'] == $linkTypeLiteral) {
          if (strpos($sparqlTestObjectExistence, $subjectPidPlaceHolder)) {
            $sparqlTestObjectExistence = str_replace($subjectPidPlaceHolder, $subjectPid, $sparqlTestObjectExistence);
          }
        }
      }

      // For dataset processing, replace the user-collection-place-holder
      // with the actual user collection.
      if (strlen($userCollection) > 0 && strpos($sparqlTestObjectExistence, $userCollectionPlaceHolder)) {
        $userCollectionFullPid = 'info:fedora/' . $userCollection;
        $sparqlTestObjectExistence = str_replace($userCollectionPlaceHolder, $userCollectionFullPid, $sparqlTestObjectExistence);
      }
      $limit = -1;
      $connection = new RepositoryConnection();
      $repquery = new RepositoryQuery($connection);

      $objectExistenceQueryResults = $repquery->sparqlQuery($sparqlTestObjectExistence, $limit);
      //$objectExistenceQueryResults = ObjectHelper::performRiQuery($sparqlTestObjectExistence, 'sparql', $limit, $offset);
      $objectExistenceCount = 0;
      foreach ($objectExistenceQueryResults as $objectExistenceQueryResult) {
        if ($rdf_relationship['link_type'] == $linkTypeLiteral) {
          // In the case of a literal, for the purposes of string comparison,
          // the text is the equivalent of the object-pid in non-literal types.
          $objectExistenceTitle = 'not_applicable';
          $objectExistencePid = $objectExistenceQueryResult['text'];
        }
        else {
          $objectExistenceTitle = $objectExistenceQueryResult['title'];
          $objectExistencePid = $objectExistenceQueryResult['object'];
        }
        $objectExistenceCount += 1;
      }

      if ($objectExistenceCount == 0) {
        if ($rdf_relationship['object_creation_required']) {
          $newObjectNamespacePrefix = $rdf_relationship['object_namespace_prefix'];
          //$newObjectPid = fedora_item::get_next_PID_in_namespace($newObjectNamespacePrefix);
          //$ingestobject = islandora_ingest_form_get_object($form_state); 
          $object = islandora_ingest_form_get_object($form_state);
          //$pid = $form_state['build_info']['args'][0]['objects'][0]->id;
          //$ingestobject = islandora_object_load($pid);
          $newObjectPid = $object->repository->getNextIdentifier($newObjectNamespacePrefix, variable_get('islandora_basic_collection_generate_uuid', FALSE));
          $link['pid'] = $newObjectPid;
          $rdf_relationship['rdf_link'][$rdfRelationshipRdfLinkCount]['pid'] = $newObjectPid;
          $newobject = presubmit_add_object_batch($newObjectPid, $rdf_relationship, $subjectPid, $link['data'], $editFlag, $postEditSubjectTitle, $subjectDCTitle, $link['data']);

          //$batch['operations'][] = array('add_object_batch', array($newObjectPid, $rdf_relationship, $subjectPid, $link['data'], $editFlag, $postEditSubjectTitle, $subjectDCTitle, $link['data']));
        }
      }
      else if ($objectExistenceCount == 1) {
        $link['pid'] = $objectExistencePid;
        $rdf_relationship['rdf_link'][$rdfRelationshipRdfLinkCount]['pid'] = $objectExistencePid;

        if ($editFlag && $rdf_relationship['symmetry_in_object_datastream_required'] && $replaceSubjectTitleInObjectDatastream) {
          // The editor has changed the title of the subject-object
          // so this must be reflected in the object-object
          // datastream that contains it.
          if ($preEditObjectTriplesForRelationship) {
            $preEditMatchFound = false;
            foreach ($preEditObjectTriplesForRelationship as $preEditObjectTripleForRelationship) {
              if (!strcmp($preEditObjectTripleForRelationship['objectPid'], $objectExistencePid)) {
                $preEditMatchFound = true;
              }
            }
            if ($preEditMatchFound) {
              replace_text_in_datastream_batch($rdf_relationship, $objectExistencePid, $preEditSubjectTitle, $postEditSubjectTitle);
            }
          }
        }
      }
      else {
        if ($editFlag) {
          $msgInsert = $postEditSubjectTitle;
        }
        else {
          $msgInsert = $subjectDCTitle;
        }
        $msg = 'While processing "' . $msgInsert . '" with ID "' . $subjectPid . '" and attempting to create a "' . $rdfName . '" link to "' . $link['data'] . '" more than one record was found with the same title, so the link was not created.';
        //drupal_set_message(t($msg));
      }
    }
    // If we are dealing with a literal type that
    // does not exist, or, in the case of the other
    // types, an object-pid exists, create the 
    // appropriate RDF links.
    if (($rdf_relationship['link_type'] == $linkTypeLiteral && $objectExistenceCount == 0) || strcmp($link['pid'], 'nopid')) {
      $relationsarray = presubmit_create_rdf_links_batch($rdf_relationship, $subjectPid, $link['pid'], $link['data'], $rdfName, $rdfNamespace, $inverseName, $inversePredicate, $editFlag, $subjectDCTitle, $postEditSubjectTitle, $linkTypeOutwardOnly, $linkTypeOutwardAndInverse, $linkTypeInverseOnly, $linkTypeLiteral);
      foreach ($relationsarray as $newrelation) {
        //array($objectPid, $rdfNamespace, $inverseName, $subjectPid);
        $newobjectpid = $newrelation[0];
        $newrdfNamespace = $newrelation[1];
        $newinversename = $newrelation[2];
        $newsubjectPid = $newrelation[3];
        if (count($newrelation) > 4) {
          //type has also been specified
          $newtype = $newrelation[4]; //might be null
        }
        $relobject = islandora_object_load($newobjectpid);
        if ($relobject) {
          if (is_null($newtype)) {
            $relobject->relationships->add($newrdfNamespace, $newinversename, $newsubjectPid);
          }
          else {
            $relobject->relationships->add($newrdfNamespace, $newinversename, $newsubjectPid, $newtype);
          }
        }
      }
      create_rdf_links_batch($rdf_relationship, $subjectPid, $link['pid'], $link['data'], $rdfName, $rdfNamespace, $inverseName, $inversePredicate, $editFlag, $subjectDCTitle, $postEditSubjectTitle, $linkTypeOutwardOnly, $linkTypeOutwardAndInverse, $linkTypeInverseOnly, $linkTypeLiteral);
    }
    $rdfRelationshipRdfLinkCount += 1;
    if ($newobject) {
      $form_state['islandora']['objects'][] = $newobject;
    }
  }
}

/**
 * Processes RDF-links and datastream modifications corresponding
 * to specific entries in the subject-object datastream.
 *
 * @param array $batch
 *   The array that controls batch processing
 * @param array $rdf_relationship
 *   Corresponds to a single RDF-autocomplete associated with an XML-form.
 * @param boolean $editFlag
 *   Indicates whether the subject-object is being edited.
 * @param string  $userCollection
 *   The identifier for the user in dataset processing. Not
 *   used for non-dataset processing.
 * @param array   $preEditObjectTriplesForRelationship
 *   The RDF links that were present previous to the user edit.
 * @param boolean $replaceSubjectTitleInObjectDatastream
 *   Flag to indicate that a change to the subject-object title
 *   necessitates an update to that string where it appears
 *   in an object-object datastream.
 * @param string $subjectPid
 *   The Persistent Identifier of the subject-object in the RDF
 * @param array  $subject
 *   The loaded subject-object
 * @param string $subjectDCTitle
 *   Contains the title of the subject for a newly ingested
 *   subject-object
 * @param string $preEditSubjectTitle
 *   If the user has edited an existing subject-object this
 *   contains the title of the subject-object prior
 *   to the XML form having been edited by the user.
 * @param string $postEditSubjectTitle
 *   If the user has edited an existing subject-object this
 *   contains the title of the subject object after
 *   the XML form has been edited by the user.
 * @param string $rdfName
 *   The verb of the predicate component in the RDF
 * @param string $inverseName
 *   The verb of the predicate component in the inverse RDF
 * @param string $rdfNamespace
 *   The stem of the predicate component in the RDF
 * @param string $inversePredicate
 *   The inverse of the predicate associated with the subject-object
 * @param int $linkTypeOutwardOnly
 *   Constant for link type that is subject to object only
 * @param int $linkTypeOutwardAndInverse
 *   Constant for link type that is subject to object and object to subject
 * @param int $linkTypeInverseOnly
 *   Constant for link type that is object to subject only
 * @param int $linkTypeLiteral
 *   Constant for link type that is subject only
 * return
 *   None
 */
function process_instances_of_this_relationship(&$batch, &$rdf_relationship, &$editFlag, &$userCollection, &$preEditObjectTriplesForRelationship, &$replaceSubjectTitleInObjectDatastream, &$subjectPid, &$subject, &$subjectDCTitle, &$preEditSubjectTitle, &$postEditSubjectTitle, &$rdfName, &$inverseName, &$rdfNamespace, &$inversePredicate, &$linkTypeOutwardOnly, &$linkTypeOutwardAndInverse, &$linkTypeInverseOnly, &$linkTypeLiteral) {
  module_load_include('inc', 'fedora_repository', 'api/tuque');
  module_load_include('inc', 'fedora_repository', 'ObjectHelper');
  module_load_include('inc', 'fedora_repository', 'api/fedora_item');

  $userCollectionPlaceHolder = 'user_collection_place_holder';
  $searchTermPlaceHolder = 'search_term_place_holder';
  $subjectPidPlaceHolder = 'subject_pid_place_holder';
  $rdfRelationshipRdfLinkCount = 0;
  foreach ($rdf_relationship['rdf_link'] as $link) {
    // If it is a literal type, we only need to check whether
    // an identical link and content already exist. However,
    // for all other types, if the user selected data from the 
    // autocomplete list, and object_pid_append_required is set,
    // there should be an object-pid associated with it.
    // However, it may not have been set or, even if it was set,
    // the user may have typed in some data and this data might
    // correspond to the title of an existing object, so check
    // if such an object exists and obtain its PID if it does,
    // so that an RDF link can be created to it.
    // If no existing object exists, but the autocomplete has been
    // set up such that the object should be created in such a
    // scenario, then create the object so that an RDF link
    // from the subject-object can be created to it.
    if (is_string($link['pid'])) {
      $linkpid = $link['pid'];
    }
    else {
      $linkpid = $link['pid']['value'];
    }
    if ((strcmp($linkpid, 'nopid') === 0) && strlen($link['data']) > 0) {
      // Construct a sparql query to check for the exitence of
      // the object.
      if ($rdf_relationship['object_creation_required']) {
        // As object creation is required, the sparql query is
        // constructed from the criteria specified in the relevant 
        // fields of the autocomplete record, e.g. the Object
        // Content Model and Collection Pids.
        $sparqlTestObjectExistence = sprintf('SELECT ?title ?object FROM <info:edu.si.fedora#ri> WHERE { ?object <%stitle> ?title; <fedora-model:hasModel> <info:fedora/%s>; <fedora-rels-ext:isMemberOfCollection> <info:fedora/%s> FILTER (regex(str(?title), "^%s$", "i"))}', PURL_ELEMENTS_URI, $rdf_relationship['object_content_model_pid'], $rdf_relationship['object_collection_pid'], escape_for_sparql($link['data']));
      }
      else {
        // As object creation is not required, the sparql query
        // that is used for the auto-complete is used instead
        // as this allows for greater flexibility.
        $sparqlTestObjectExistence = $rdf_relationship['sparql_field'];

        if (strpos($sparqlTestObjectExistence, $searchTermPlaceHolder)) {
          // Substitute the data for the search term place holder and
          // add a dollar sign so that an exact match is specified.
          $linkDataPlusDollar = escape_for_sparql($link['data']) . '$';
          $sparqlTestObjectExistence = str_replace($searchTermPlaceHolder, $linkDataPlusDollar, $sparqlTestObjectExistence);
        }
        if ($rdf_relationship['link_type'] == $linkTypeLiteral) {
          if (strpos($sparqlTestObjectExistence, $subjectPidPlaceHolder)) {
            $sparqlTestObjectExistence = str_replace($subjectPidPlaceHolder, $subjectPid, $sparqlTestObjectExistence);
          }
        }
      }

      // For dataset processing, replace the user-collection-place-holder
      // with the actual user collection.
      if (strlen($userCollection) > 0 && strpos($sparqlTestObjectExistence, $userCollectionPlaceHolder)) {
        $userCollectionFullPid = 'info:fedora/' . $userCollection;
        $sparqlTestObjectExistence = str_replace($userCollectionPlaceHolder, $userCollectionFullPid, $sparqlTestObjectExistence);
      }
      $limit = -1;
      $connection = new RepositoryConnection();
      $repquery = new RepositoryQuery($connection);

      $objectExistenceQueryResults = $repquery->sparqlQuery($sparqlTestObjectExistence, $limit);
      //$objectExistenceQueryResults = ObjectHelper::performRiQuery($sparqlTestObjectExistence, 'sparql', $limit, $offset);
      $objectExistenceCount = 0;
      foreach ($objectExistenceQueryResults as $objectExistenceQueryResult) {
        if ($rdf_relationship['link_type'] == $linkTypeLiteral) {
          // In the case of a literal, for the purposes of string comparison,
          // the text is the equivalent of the object-pid in non-literal types.
          $objectExistenceTitle = 'not_applicable';
          $objectExistencePid = $objectExistenceQueryResult['text'];
        }
        else {
          $objectExistenceTitle = $objectExistenceQueryResult['title'];
          $objectExistencePid = $objectExistenceQueryResult['object'];
        }
        $objectExistenceCount += 1;
      }

      if ($objectExistenceCount == 0) {
        if ($rdf_relationship['object_creation_required']) {
          $newObjectNamespacePrefix = $rdf_relationship['object_namespace_prefix'];
          //$newObjectPid = fedora_item::get_next_PID_in_namespace($newObjectNamespacePrefix);
          $ingestobject = islandora_object_load($subjectPid);
          $newObjectPid = $ingestobject->repository->getNextIdentifier($newObjectNamespacePrefix, variable_get('islandora_basic_collection_generate_uuid', FALSE));


          $link['pid'] = $newObjectPid;
          $rdf_relationship['rdf_link'][$rdfRelationshipRdfLinkCount]['pid'] = $newObjectPid;
          presubmit_add_object_batch($newObjectPid, $rdf_relationship, $subjectPid, $link['data'], $editFlag, $postEditSubjectTitle, $subjectDCTitle, $link['data']);
        }
      }
      else if ($objectExistenceCount == 1) {
        $link['pid'] = $objectExistencePid;
        $rdf_relationship['rdf_link'][$rdfRelationshipRdfLinkCount]['pid'] = $objectExistencePid;

        if ($editFlag && $rdf_relationship['symmetry_in_object_datastream_required'] && $replaceSubjectTitleInObjectDatastream) {
          // The editor has changed the title of the subject-object
          // so this must be reflected in the object-object
          // datastream that contains it.
          if ($preEditObjectTriplesForRelationship) {
            $preEditMatchFound = false;
            foreach ($preEditObjectTriplesForRelationship as $preEditObjectTripleForRelationship) {
              if (!strcmp($preEditObjectTripleForRelationship['objectPid'], $objectExistencePid)) {
                $preEditMatchFound = true;
              }
            }
            if ($preEditMatchFound) {
              replace_text_in_datastream_batch($rdf_relationship, $objectExistencePid, $preEditSubjectTitle, $postEditSubjectTitle);
            }
          }
        }
      }
      else {
        if ($editFlag) {
          $msgInsert = $postEditSubjectTitle;
        }
        else {
          $msgInsert = $subjectDCTitle;
        }
        $msg = 'While processing "' . $msgInsert . '" with ID "' . $subjectPid . '" and attempting to create a "' . $rdfName . '" link to "' . $link['data'] . '" more than one record was found with the same title, so the link was not created.';
        //drupal_set_message(t($msg));
      }
    }
    // If we are dealing with a literal type that
    // does not exist, or, in the case of the other
    // types, an object-pid exists, create the 
    // appropriate RDF links.
    if (is_array($link['pid'])) {
      $linkpid = $link['pid']['value'];
    }
    else {
      $linkpid = $link['pid'];
    }
    if (($rdf_relationship['link_type'] == $linkTypeLiteral && $objectExistenceCount == 0) || strcmp($linkpid, 'nopid')) {
      //$batch['operations'][] = array('create_rdf_links_batch', array($rdf_relationship, $subjectPid, $link['pid'], $link['data'], $rdfName, $rdfNamespace, $inverseName, $inversePredicate, $editFlag, $subjectDCTitle, $postEditSubjectTitle, $linkTypeOutwardOnly, $linkTypeOutwardAndInverse, $linkTypeInverseOnly, $linkTypeLiteral));
      create_rdf_links_batch($rdf_relationship, $subjectPid, $linkpid, $link['data'], $rdfName, $rdfNamespace, $inverseName, $inversePredicate, $editFlag, $subjectDCTitle, $postEditSubjectTitle, $linkTypeOutwardOnly, $linkTypeOutwardAndInverse, $linkTypeInverseOnly, $linkTypeLiteral);
    }
    $rdfRelationshipRdfLinkCount += 1;
  }
}

/**
 * Retrieve the pre-edit title and post-edit
 * title from the form array.
 * Serializing the entire form-array and then
 * doing a string search for the relevant fields
 * is very ugly. Unfortunately there does not
 * seem to be any other way of obtaining this
 * data because it is impossible to search a
 * multidimensional array with a string, even
 * if the string exactly mimics the equivalent
 * PHP statement that would access the desired
 * variables.
 *
 * @param array $form
 *   The array containing the XML-Form data.
 * @param string $subjectXpathTitleSearch
 *   The Xpath string that identifies the 
 *   title of the subject-object
 * @return
 *   Array containing pre and post edit titles
 *   or NULL
 */
function get_pre_and_post_edit_subject_titles_from_form(&$form, $subjectXpathTitleSearch) {
  $title = array();
  $preEditTitle = '';
  $postEditTitle = '';
  $preEditTitleFieldLabel = "#default_value";
  $postEditTitleFieldLabel = "#value";
  $startFieldDelim = '"';
  $endFieldDelim = '";s'; // If it were just the double-quote, it would not process titles that contained quotes correctly.
  $serializedForm = serialize($form);
  $xpathMatched = strstr($serializedForm, $subjectXpathTitleSearch);
  if ($xpathMatched) {
    $preEditTitleFieldLabelMatched = strstr($xpathMatched, $preEditTitleFieldLabel);
    if ($preEditTitleFieldLabelMatched) {
      $afterPreEditFieldLabel = substr($preEditTitleFieldLabelMatched, (strlen($preEditTitleFieldLabel) + 1));
      $startPreEditTitleFieldDelim = strstr($afterPreEditFieldLabel, $startFieldDelim);
      if ($startPreEditTitleFieldDelim) {
        $endPreEditTitleFieldDelimPos = strpos($startPreEditTitleFieldDelim, $endFieldDelim, 1);
        if ($endPreEditTitleFieldDelimPos > 0) {
          $endPreEditTitleFieldPos = $endPreEditTitleFieldDelimPos - 1;
          $preEditTitle = substr($startPreEditTitleFieldDelim, 1, $endPreEditTitleFieldPos);
        }
        $postEditTitleFieldLabelMatched = strstr($startPreEditTitleFieldDelim, $postEditTitleFieldLabel);
        if ($postEditTitleFieldLabelMatched) {
          $afterPostEditFieldLabel = substr($postEditTitleFieldLabelMatched, (strlen($postEditTitleFieldLabel) + 1));
          $startPostEditTitleFieldDelim = strstr($afterPostEditFieldLabel, $startFieldDelim);
          if ($startPostEditTitleFieldDelim) {
            $endPostEditTitleFieldDelimPos = strpos($startPostEditTitleFieldDelim, $endFieldDelim, 1);
            if ($endPostEditTitleFieldDelimPos > 0) {
              $endPostEditTitleFieldPos = $endPostEditTitleFieldDelimPos - 1;
              $postEditTitle = substr($startPostEditTitleFieldDelim, 1, $endPostEditTitleFieldPos);
            }
          }
        }
      }
    }
  }

  if (strlen($preEditTitle) > 0 && strlen($postEditTitle) > 0) {
    $title[] = $preEditTitle;
    $title[] = $postEditTitle;
    return $title;
  }
  else {
    return NULL;
  }
}

/**
 * Escapes various characters that would otherwise
 * cause a SPARQL query to fail.
 *
 * @param string $inputString
 *   The string in which the escaping is to be performed.
 * return string $inputString
 *   A string with the characters escaped.
 */
function escape_for_sparql($inputString) {
  if (strlen($inputString) > 0) {
    $inputString = str_replace('(', '\\\(', $inputString);
    $inputString = str_replace(')', '\\\)', $inputString);
    $inputString = str_replace('{', '\\\{', $inputString);
    $inputString = str_replace('}', '\\\{', $inputString);
    $inputString = str_replace('+', '\\\+', $inputString);
    $inputString = str_replace('?', '\\\?', $inputString);
    $inputString = str_replace('^', '\\\^', $inputString);
    $inputString = str_replace('*', '\\\*', $inputString);
    $inputString = str_replace('.', '\\\.', $inputString);
    $inputString = str_replace('"', '\\\"', $inputString);
    $inputString = str_replace("'", "\\\'", $inputString);
    return $inputString;
  }
  else {
    return '';
  }
}

/**
 * Performs an spo query of the triple-store and returns an array
 * of object PIDS derived from the query results.
 *
 * @param string $subject
 *   The subject component of the required spo query
 * @param string $predicate
 *   The predicate component of the required spo query
 * @param string $object
 *   The object component of the required spo query
 * return
 *   Array of triples returned by the spo query
 *   or NULL
 */
function spo_search($subject = '*', $predicate = '*', $object = '*') {
  module_load_include('inc', 'fedora_repository', 'api/fedora_utils');
  $query = $subject . ' ' . $predicate . ' ' . $object;
  $offset = 0;
  $limit = 10000;
  $content = '';
  $selectables = '';
  $wherecontent = '';
  $onewildcard = FALSE;
  if (strcmp($subject, '*') === 0) {
    $selectables .= '$s ';
    $wherecontent .= '$s ';
    $onewildcard = TRUE;
  }
  else {
    $wherecontent .= $subject . ' ';
  }
  if (strcmp($predicate, '*') === 0) {
    $selectables .= '$p ';
    $wherecontent .= '$p ';
    $onewildcard = TRUE;
  }
  else {
    $wherecontent .= $predicate . ' ';
  }
  if (strcmp($object, '*') === 0) {
    $selectables .= '$o ';
    $wherecontent .= '$o ';
    $onewildcard = TRUE;
  }
  else {
    $wherecontent .= $object . ' ';
  }

  if (!$onewildcard) { //ie all 3 have values
    //put in a dummy yet known value.
    $selectables .= '$d ';
    $wherecontent .= ' . ' . $subject . '<http://purl.org/dc/elements/1.1/identifier> $d ';
  }
  $sparqlquery = 'SELECT ' . $selectables . ' from <info:edu.si.fedora#ri> where {' . $wherecontent . '}';

  $repository = islandora_get_tuque_connection()->repository;
  $ri = $repository->ri;
  $contentarray = $ri->sparqlQuery($sparqlquery, $limit);
  foreach ($contentarray as $contentitem) { //SFOX recreate the output structure from the old SPO search
    foreach ($contentitem as $selecteditem => $contentvalues) {
      switch ($selecteditem) {
        case 's': {
            $content .= '<' . $contentvalues['uri'] . '> ' . $predicate . ' ' . $object . ' . ';
            break;
          }
        case 'p' : {
            $content .= $subject . ' <' . $contentvalues['uri'] . '> ' . $object . ' . ';
            break;
          }
        case 'o' : {
            $content .= $subject . ' ' . $predicate . ' <' . $contentvalues['uri'] . '> . ';
            break;
          }
        case 'd' : {
            $content .= $subject . ' ' . $predicate . ' ' . $object . ' . ';
            break;
          }
      }
    }
  }

  if ($content) {
    $content = str_replace("\n", '', $content);
    $content = str_replace('"', '', $content);
    $content = str_replace("\\", '', $content);
    $triples = explode(" .", $content);
    $tripleCount = count($triples) - 1;
    $subjectElement = 0;
    $predicateElement = 1;
    $objectElement = 2;
    $pidPref = 'info:fedora';
    $pidPrefLen = strlen($pidPref);
    $bracketLen = 1;
    $slashLen = 1;
    $processedTriples = array();
    for ($i = 0; $i < $tripleCount; $i++) {
      $elements = explode("> ", $triples[$i]);
      $namespacedSubjectPid = substr($elements[$subjectElement], $bracketLen + $pidPrefLen + $slashLen);
      $requiredPredicateElementLen = strlen($elements[$predicateElement]) - 1;
      $predicateOfTriple = substr($elements[$predicateElement], 1, $requiredPredicateElementLen);

      if (strpos($elements[$objectElement], $pidPref) > 0) {
        $objectElementLen = strlen($elements[$objectElement]);
        $pidLen = $objectElementLen - ($bracketLen + $pidPrefLen + $slashLen + $bracketLen);
        $namespacedObjectPid = substr($elements[$objectElement], $bracketLen + $pidPrefLen + $slashLen, $pidLen);
      }
      else {
        // No object pid has been found, so
        // this must be an RDF literal. Therefore
        // obtain the text instead.
        $namespacedObjectPid = trim($elements[$objectElement]);
      }
      $processedTriples[] = array("subjectPid" => $namespacedSubjectPid, "predicate" => $predicateOfTriple, "objectPid" => $namespacedObjectPid);
    }
    return $processedTriples;
  }
  else {
    return NULL;
  }
}

/**
 * Search for a match for a specific node element content in the
 * specified datastream and object. If there is more than one such
 * node-group present, remove the entire node. Otherwise, just
 * remove the content of the node element. Update the datastream
 * of the actual object.
 *
 * @param array $rdf_relationship
 *   Corresponds to a single RDF-autocomplete associated with an XML-form.
 * @param string $objectPid
 *   The PID of the object in which the datastream resides.
 * @param string $objectXpathSearch
 *   The XPath statement that searches the datastream
 * @param string $objectXpathBuildCountback
 *   The number of nodes, counting backwards that should
 *   be removed, when group-node removal is required.
 * @param string $elementContent
 *   The node element to be matched
 * return
 *   None
 */
function remove_from_datastream(&$rdf_relationship, $objectPid, $objectXpathSearch, $objectXpathBuildCountback, $elementContent) {

  $objectDatastreamID = $rdf_relationship['object_dsid'];
  $object = islandora_object_load($objectPid);
  $objectDatastream = $object[$objectDatastreamID];
  $objectDatastreamXml = $objectDatastream->content;
  $objectDoc = new domDocument();
  $objectDoc->loadXML($objectDatastreamXml);
  $objectXpath = new domXpath($objectDoc);
  register_xpath_namespaces($objectXpath, $rdf_relationship['object_namespace_info']);
  $removeNodeQueryResults = $objectXpath->query($objectXpathSearch);
  $removeNodeQueryResultsTot = $removeNodeQueryResults->length;
  if ($removeNodeQueryResultsTot > 0) {
    foreach ($removeNodeQueryResults as $node) {
      if (!strcmp($node->nodeValue, $elementContent)) {
        if ($removeNodeQueryResultsTot == 1) {
          $node->nodeValue = '';
        }
        else {
          for ($x = 1; $x <= $objectXpathBuildCountback; $x++) {
            $childNode = $node;
            $parentNode = $childNode->parentNode;
            $node = $parentNode;
          }
          $parentNode->removeChild($childNode);
        }
      }
    }
    // Update the datastream with the changed xml.
    $updatedObjectDatastreamXml = $objectDoc->saveXML();
    $objectDatastream->content = $updatedObjectDatastreamXml;
  }
}

/**
 * Search for a match for a specific node element content in the
 * specified datastream and object. Replace the content of the
 * of the first node that matches the search with the string provided.
 *
 * @param array $rdf_relationship
 *   Corresponds to a single RDF-autocomplete associated with an XML-form.
 * @param string $objectPid
 *   The PID of the object in which the datastream resides.
 * @param string $objectXpathSearch
 *   The XPath statement that searches the datastream
 * @param string $elementContent
 *   The node element value to be matched and replaced
 * @param string $replacementContent
 *   The node element value that replaces the matched value
 * return
 *   None
 */
function replace_text_in_datastream(&$rdf_relationship, $objectPid, $objectXpathSearch, $elementContent, $replacementContent) {
  module_load_include('inc', 'fedora_repository', 'api/tuque');

  $objectDatastreamID = $rdf_relationship['object_dsid'];
  $object = islandora_object_load($objectPid);
  $objectDatastream = $object[$objectDatastreamID];
  $objectDatastreamXml = $objectDatastream->content;
  $objectDoc = new domDocument();
  $objectDoc->loadXML($objectDatastreamXml);
  $objectXpath = new domXpath($objectDoc);
  register_xpath_namespaces($objectXpath, $rdf_relationship['object_namespace_info']);
  $replaceNodeQueryResults = $objectXpath->query($objectXpathSearch);
  $replaceNodeQueryResultsTot = $replaceNodeQueryResults->length;
  if ($replaceNodeQueryResultsTot > 0) {
    foreach ($replaceNodeQueryResults as $node) {
      if (!strcmp($node->nodeValue, $elementContent)) {
        $node->nodeValue = $replacementContent;
        break;
      }
    }
    // Update the datastream with the changed xml.
    $updatedObjectDatastreamXml = $objectDoc->saveXML();
    $objectDatastream->content = $updatedObjectDatastreamXml;
  }
}

/**
 *
 * Search for a match for a specific node element content in the
 * specified datastream. If it is already present, do nothing.
 * If an empty node is present, add the content to it. Otherwise,
 * add the required node-group with the content set.
 * The datastream of the object is not updated within this
 * function because the object may not exist at the point at
 * which this function is called.
 *
 * @param array $rdf_relationship
 *   Corresponds to a single RDF-autocomplete associated with an XML-form.
 * @param string $objectDatastreamXml
 *   The datastream to which the data is added.
 * @param string $objectXpathSearch
 *   The XPath statement that searches the datastream
 * @param string $objectXpathBulid
 *   The pseudo-XPath that provides a template to build
 *   the XML for adding a node-group when necessary.
 * @param string $objectXpathBuildCountback
 *   The number of nodes, counting backwards that should
 *   be added, when group-node addition is required.
 * @param string $elementContent
 *   The node element content to be added.
 * return
 *   true or false to indicate error
 */
function add_to_datastream(&$rdf_relationship, &$objectDatastreamXml, $objectXpathSearch, $objectXpathBuild, $objectXpathCountback, $elementContent) {
  $returnValue = true;
  $objectDoc = new domDocument();
  $objectDoc->loadXML($objectDatastreamXml);
  $objectXpath = new domXpath($objectDoc);
  register_xpath_namespaces($objectXpath, $rdf_relationship['object_namespace_info']);
  $objectQueryResults = $objectXpath->query($objectXpathSearch);

  $objectQueryResultsTot = $objectQueryResults->length;
  $elementContentAddedToObjectDS = false;
  $elementContentAlreadyPresent = false;
  // Check whether the relevant xml node is present.
  if ($objectQueryResultsTot > 0) {
    foreach ($objectQueryResults as $objectQueryResult) {
      $objectItem = trim($objectQueryResult->textContent);
      // Check if the specific element content is present (case insensitive).
      if (!strcasecmp($objectItem, $elementContent)) {
        $elementContentAlreadyPresent = true;
        break;
        // Check if there is an empty element available.
      }
      else if (strlen($objectItem) == 0) {
        if (!$elementContentAddedToObjectDS) {
          $objectQueryResult->nodeValue = $elementContent;
          // Update the datastream with the xml containing the
          // updated node.
          $objectDatastreamXml = $objectDoc->saveXML();
          $elementContentAddedToObjectDS = true;
          break;
        }
      }
    }
  }
  if (!$elementContentAddedToObjectDS && !$elementContentAlreadyPresent) {
    // Add a new node containing the element content.
    $objectXpathComponents = explode('/', $objectXpathBuild);
    $objectXpathComponentsTot = count($objectXpathComponents);
    $startObjectXpathComponent = $objectXpathComponentsTot - $objectXpathCountback;
    $nodePref = 'node';
    for ($objectXpathComponentCount = $objectXpathComponentsTot; $objectXpathComponentCount > $startObjectXpathComponent; $objectXpathComponentCount--) {
      $elementDefinition = $objectXpathComponents[$objectXpathComponentCount - 1];
      $attributePhraseStart = strpos($elementDefinition, '[');
      $attributePhrase = strstr($elementDefinition, '[');
      if (strlen($attributePhraseStart) == 0) {
        ${$nodePref . $objectXpathComponentCount} = $objectDoc->createElement($elementDefinition);
      }
      else {
        $elementName = substr($elementDefinition, 0, $attributePhraseStart);
        ${$nodePref . $objectXpathComponentCount} = $objectDoc->createElement($elementName);
        $attributePhrase = substr($attributePhrase, 1);
        $delimPos = strpos($attributePhrase, ']');
        if ($delimPos !== false) {
          $attributePhrase = substr($attributePhrase, 0, $delimPos);
          if (strlen($attributePhrase) > 0) {
            $attributeAndPresent = strpos($attributePhrase, ' and ');
            if ($attributeAndPresent > 0) {
              $attributes = explode(' and ', $attributePhrase);
            }
            else {
              $attributes = array();
              $attributes[0] = $attributePhrase;
            }
            $attributesTot = count($attributes);
            // Attach any attributes that are present to the
            // current node.
            for ($x = 0; $x < $attributesTot; $x++) {
              $attribute = explode('=', $attributes[$x]);
              $attribute[0] = trim($attribute[0]);
              if (strlen($attribute[0]) > 0) {
                $attributeTerm = substr($attribute[0], 1);
                $domAttribute = $objectDoc->createAttribute($attributeTerm);
                if (strlen($attribute[1]) > 2) {
                  $attribute[1] = trim($attribute[1]);
                  $attributeValue = substr($attribute[1], 1, strlen($attribute[1]) - 2); // Strip off quotes.
                  $domAttribute->value = $attributeValue;
                  ${$nodePref . $objectXpathComponentCount}->appendChild($domAttribute);
                }
              }
            }
          }
        }
      }
      if ($objectXpathComponentCount == $objectXpathComponentsTot) {
        $whatIsThis = $objectXpathComponents[$objectXpathComponentCount - 1];
        ${$nodePref . $objectXpathComponentCount}->appendChild($objectDoc->createTextNode($elementContent));
      }
      else {
        $prevObjectXpathComponentCount = $objectXpathComponentCount + 1; //Incrementing by one here rather than within the appendChild function is necessary for the values to concatenate correctly for the variable-variable name.
        ${$nodePref . $objectXpathComponentCount}->appendChild(${$nodePref . $prevObjectXpathComponentCount});
      }
    }

    $objectXpathStem = $objectXpathSearch;
    for ($y = 0; $y < $objectXpathCountback; $y++) {
      $objectXpathStemPos = strrpos($objectXpathStem, '/');
      $objectXpathStem = substr($objectXpathStem, 0, $objectXpathStemPos);
    }
    $queryResults = $objectXpath->query($objectXpathStem);
    $queryResultsTot = $queryResults->length;
    // Loop through results in order to append node at the correct point.
    if ($queryResultsTot > 0) {
      foreach ($queryResults as $queryResult) {
        $dataReport = $queryResult->textContent;
      }
    }
    // Append the node.
    $prevObjectXpathComponentCount = $objectXpathComponentCount + 1;
    if ($queryResultsTot > 0) {
      $queryResult->appendChild(${$nodePref . $prevObjectXpathComponentCount});

      // Update the datastream with the xml containing the added node.
      $objectDatastreamXml = $objectDoc->saveXML();
    }
    else {
      $returnValue = false;
    }
  }
  return $returnValue;
}

/**
 *
 * Get the contents from the datastream specified by the arguments
 * for the object passed in as a parameter. This is a local function
 * that is similar to the get_datastream_content_via_xpath function
 * in GenericFunctions.inc in the fba_utiity module. A modified
 * local version is present here for performance reasons as it takes
 * a parameter of an object that has already been loaded.
 *
 * @param array $object
 *   The object from which the content specified by the xpath
 *   query is to be obtained.
 * @param string $datastremLabel
 *   The label of the datastream that is to be queried
 * @param string $namespace
 *   The namespace to be registered for the xpath query
 * @param string $xpathQuery
 *   The xpath query to identify the required content
 * return string
 *   The required content or NULL
 */
function get_datastream_content_via_xpath_local(&$object, $datastreamLabel, $namespace, $xpathQuery) {
  $datastream = $object[$datastreamLabel];
  $xml = $datastream->content;
  $doc = new domDocument();
  $doc->loadXML($xml);
  $xpath = new domXpath($doc);
  $xpath->registerNamespace(strtolower($datastreamLabel), $xpathQuery);
  $xpathQueryResults = $xpath->query($xpathQuery);

  $xpathQueryResultCount = 0;
  if ($xpathQueryResults->length > 0) {
    foreach ($xpathQueryResults as $xpathQueryResult) {
      $target = $xpathQueryResult->textContent;
      $xpathQueryResultCount += 1;
    }
  }

  if ($xpathQueryResultCount == 1) {
    return $target;
  }
  else {
    return '';
  }
}

/**
 *
 * Get the form name associated with the object PID and
 * content model ID that are passed as parameters.
 * If more than one form is associated with the content
 * model, output an error message and return an empty
 * string.
 *
 * @param string $objectPid
 *   The PID of the object for which the form name associated with
 *   the content model is to be found.
 * @param string $contentModelPid
 *   The PID of the content model associated with form name.
 * return string
 *   The XML-form name or an empty string.
 */
function get_object_linker_form_name($objectPid, $contentModelPid) {
  $existing_json_sidora_form_config = variable_get('xsl_form_config', '');
  $sfc = json_decode($existing_json_sidora_form_config);

  foreach ($sfc->xsl_config as $config_line) {
    if (strcmp($contentModelPid, $config_line->model) === 0) {
      $form_name = $config_line->form;
      break;
    }
  }
  return $form_name;
  /*
    module_load_include('inc', 'fedora_repository', 'ConnectionHelper');
    module_load_include('inc', 'xml_form_builder', 'XMLFormDatabase');

    $formNameSelect = "SELECT form_name FROM {islandora_content_model_forms} WHERE content_model = '" . $contentModelPid . "'";
    $formNameSelectResult = db_query($formNameSelect);

    $formNameTot = 0;
    while ($data = db_fetch_object($formNameSelectResult)) {
    $objectLinkerFormName = $data->form_name;
    $formNameTot += 1;
    }

    if ($formNameTot == 0) {
    $objectLinkerFormName = '';
    $msg = $objectPid . ' has no form associated with the content model ' . $contentModelPid . ', therefore any links that were created by the Object Linker could not be processed.';
    drupal_set_message(t($msg), 'error');
    }
    else if ($formNameTot > 1) {
    $objectLinkerFormName = '';
    $msg = $objectPid . ', has more than one form associated with the content model ' . $contentModelPid . ', therefore any links that were created by the Object Linker could not be processed.';
    drupal_set_message(t($msg), 'error');
    }

    return $objectLinkerFormName; */
}

/**
 *
 * Register the namespace info passed in as a parameter
 * in the domxpath that is also passed as a parameter
 * so that the xml elements wth those namespaces can
 * be searched.
 *
 * @param array $domxpath
 *   The domxpath in which the namespaces are to be registered
 * @param string $namespaceInfo
 *   One or more namespace-prefix/url pairs that are to be
 *   registered.
 * @param boolean $checkPrevious
 *   If this is set the array $namespacedPrefixesRegistered
 *   is checked to see if the namespace has already been
 *   registered.
 * @param array $namespacePrefixesRegistered
 *   If $checkPrevious is set to true this array is checked
 *   for a match prior to registering the namepace. If there
 *   is a match it is not re-registered. If there is no
 *   match, it is registered and the namespace prefix is
 *   added to the array.
 * return
 *   None
 */
function register_xpath_namespaces(&$domxpath, &$namespaceInfo, $checkPrevious = false, &$namespacePrefixesRegistered = NULL) {
  $namespaceDelimiter = '==';
  $namespaceComponentDelimiter = '!!';
  $namespaces = explode($namespaceDelimiter, $namespaceInfo);
  $namespaceCount = 0;
  foreach ($namespaces as $namespace) {
    $namespaceComponents = explode($namespaceComponentDelimiter, $namespace);
    $componentCount = count($namespaceComponents);
    if ($componentCount == 2) {
      if ($checkPrevious) {
        $alreadyRegistered = false;
        if (count($namespacePrefixesRegistered) > 0) {
          foreach ($namespacePrefixesRegistered as $namespacePrefixRegistered) {
            if (!strcmp($namespacePrefixRegistered, $namespaceComponents[0])) {
              $alreadyRegistered = true;
              break;
            }
          }
        }
        if (!$alreadyRegistered) {
          $domxpath->registerNamespace($namespaceComponents[0], $namespaceComponents[1]);
          $namespacePrefixesRegistered[] = $namespaceComponents[0];
        }
      }
      else {
        $domxpath->registerNamespace($namespaceComponents[0], $namespaceComponents[1]);
      }
    }
    else {
      drupal_set_message(t('The name space information has been incorrectly delimited for object linking.'));
    }
    $namespaceCount += 1;
  }

  if ($namespaceCount == 0) {
    drupal_set_message(t('The required name space information has not been entered for object linking.'));
  }
}

/**
 *
 * Display in HTML the header followed by the rows
 * returned from the Sparql query as a list of
 * links.
 *
 * @param string $header
 *   The header of the list of links.
 * @param string $sparqlQuery
 *   The sparql query used to populate the list
 * @param string $clickable
 *   Determines whether the values are clickable
 * return
 *   Formatted list or empty string
 */
function get_link_list($header, $sparqlQuery, $clickable = true) {
  global $base_url;
  module_load_include('module', 'subpath_alias', 'subpath_alias');

  $sparql_field = <<<EOQ
$sparqlQuery
EOQ;
  $queryResults = get_link_array($sparqlQuery);
  if ($queryResults) {
    $formattedHtml = '<div style="clear:both"><p>' . $header;
    $formattedHtml .= '<ul style="list-style:none">';
    foreach ($queryResults as $result) {
      if ($clickable) {
        //SFOX New code to apply the pathauto translation(s)
        $path = 'fedora/repository/' . $result['pid'];
        $original_path = 'fedora/repository/' . $result['pid'];
        $options['language'] = 'en';
        subpath_alias_url_outbound_alter($path, $options, $original_path);
        $formattedHtml .= '<li>' . '<a href="' . $base_url . '/' . $path . '">' . $result['title'] . '</a></li>';
      }
      else {
        $formattedHtml .= '<li>&nbsp;' . $result['title'] . '</li>';
      }
    }
    $formattedHtml .= '</ul></p></div>';
    return $formattedHtml;
  }
  else {
    return '';
  }
}

/**
 *
 * Perform sparql query and return resulting array.
 *
 * @param string $sparqlQuery
 *   The sparql query
 * @return array
 *   Query results or NULL
 *   
 */
function get_link_array($sparqlQuery) {
  module_load_include('inc', 'fedora_repository', 'ObjectHelper');

  $sparql_field = <<<EOQ
$sparqlQuery
EOQ;
  $limit = -1;
  $offset = 0;
  $connection = new RepositoryConnection();
  $repquery = new RepositoryQuery($connection);

  $queryResults = $repquery->sparqlQuery($sparqlQuery, $limit);
  //$queryResults = ObjectHelper::performRiQuery($sparqlQuery, 'sparql', $limit, $offset);
  if (count($queryResults) > 0) {
    return $queryResults;
  }
  else {
    return NULL;
  }
}

/**
 *
 * Perform an spo search based on the subject and
 * predicate. If the spo search returns any rows,
 * a sparql query is constructed and executed that
 * returns the titles and PIDs of the fedora-objects
 * corresponding to the object of the RDF.
 * It is probably possible to achieve the same result
 * and better performance by constructing a single
 * sparql query, but I do not have time to figure
 * out how to construct it at this moment.
 *
 * @param string $subjectPid
 *   The subject PID for the spo search
 * @param string $predicate
 *   The predicate for the spo search
 * @param integer $limit
 *   A limit for the sparql query
 * @param integer $returnType
 *   Determines whether an array or html-bounded list is returned
 * @param string $header
 *   If html-bounded list type is stipulated then this is the header
 *   for the list.
 *  
 * return array
 *   Query results
 *   
 */
function get_rdf_object_entries($subjectPid, $predicate, $limit, $returnType, $header) {
  $arrayType = 0;
  $clickableListType = 1;
  $nonClickableListType = 2;
  $noLimit = -1;
  $object = '*';
  $subject = '<info:fedora/' . $subjectPid . '>';
  $spoResults = spo_search($subject, $predicate, $object);
  $spoResultsTot = count($spoResults);

  if ($spoResultsTot > 0) {
    $spoResultsCount = 0;
    $filterComponent = 'FILTER ((';
    foreach ($spoResults as $spoResult) {
      $spoResultsCount += 1;
      if ($spoResultsCount < $spoResultsTot) {
        $filterComponent .= 'sameTerm(?subject, <info:fedora/' . $spoResult['objectPid'] . '>)' . ' || ';
      }
      else {
        $filterComponent .= 'sameTerm(?subject, <info:fedora/' . $spoResult['objectPid'] . '>)' . '))';
      }
    }
    $sparqlQuery = 'SELECT ?title ?pid WHERE { ?subject <' . PURL_ELEMENTS_URI . 'identifier> ?pid; <' . PURL_ELEMENTS_URI . 'title> ?title ' . $filterComponent . ' } ORDER BY ?title';

    if ($limit > $noLimit) {
      $sparqlQuery = $sparqlQuery . ' LIMIT ' . $limit;
    }
    if ($returnType == $arrayType) {
      return get_link_array($sparqlQuery);
    }
    else if ($returnType == $clickableListType) {
      return get_link_list($header, $sparqlQuery, true);
    }
    else {
      return get_link_list($header, $sparqlQuery, false);
    }
  }
  else {
    return NULL;
  }
}

/**
 *
 * Construct a sparql query that returns the titles
 * and PIDs of the fedora-objects corresponding to
 * the object of the RDF.
 *
 * @param string $predicate
 *   The predicate for the sparql query
 * @param string $objectPid
 *   The object PID for the sparql query
 * @param integer $limit
 *   A limit for the sparql query
 * @param integer $returnType
 *   Determines whether an array or html-bounded list is returned
 * @param string $header
 *   If html-bounded list type is stipulated then this is the header
 *   for the list.
 * return array
 *   Query results
 *   
 */
function get_rdf_subject_entries($objectPid, $predicate, $limit, $returnType, $header) {
  $arrayType = 0;
  $clickableListType = 1;
  $nonClickableListType = 2;
  $noLimit = -1;
  $object = '<info:fedora/' . $objectPid . '>';
  $filterComponent = 'FILTER (sameTerm(?object,' . $object . '))';
  $sparqlQuery = 'SELECT ?title ?pid WHERE { ?subject ' . $predicate . ' ?object;  <' . PURL_ELEMENTS_URI . 'title> ?title; <' . PURL_ELEMENTS_URI . 'identifier> ?pid ' . $filterComponent . ' } ORDER BY ?title';
  if ($limit > $noLimit) {
    $sparqlQuery = $sparqlQuery . ' LIMIT ' . $limit;
  }
  if ($returnType == $arrayType) {
    return get_link_array($sparqlQuery);
  }
  else if ($returnType == $clickableListType) {
    return get_link_list($header, $sparqlQuery, true);
  }
  else {
    return get_link_list($header, $sparqlQuery, false);
  }
}

/**
 *
 * Check whether an object with a title equivalent to
 * the value passed in as a label already exists according
 * to the criteria contained in the sparql query supplied.
 *
 * @param string $label
 *   The label field from the object
 * @param string $sparqlQuery
 *   The sparql query to be used to check for a duplicate. It
 *   should select only 'title'.
 * return string
 *   Either NULL when no duplicate is found, or an error message
 *   when a duplicate is found.
 *   
 */
function check_for_duplicate_label($label, $sparqlQuery) {
  $linkArray = get_link_array($sparqlQuery);
  if (count($linkArray) > 0) {
    foreach ($linkArray as $linkItem) {
      $existingTitle = $linkItem['title'];
      break;
    }
    if (strcmp($label, $existingTitle)) {
      return 'The entry "' . $label . '" is already present within this collection as "' . $existingTitle . '", so it has not been created.';
    }
    else {
      return 'The entry "' . $label . '" is already present within this collection, so it has not been created.';
    }
  }
  else {
    return NULL;
  }
}

/**
 *
 * Add a new object with the appropriate XML and RDF links
 * as a batch operation.
 * Note that $rdf_relationship and $link are not passed by
 * reference in this instance because the original arrays
 * might no longer exist by the time this batch operation
 * is called.
 *
 * @param string $newObjectPid
 *   The Persistent Identifier for the new object
 * @param array $rdf_relationship
 *   Corresponds to a single RDF-autocomplete associated with an XML-form.
 * @param string $subjectPid
 *   The Persistent Identifier for the subject object
 * @param string $data
 *   The character string entered by the user
 * @param boolean $editFlag
 *   Indicates whether the subject object is being edited.
 * @param boolean $postEditSubjectTitle
 *   Contains the title of the subject object after
 *   the XML form has been edited by the user.
 * @param string $subjectDCTitle
 *   Contains the title of the subject object prior 
 *   to the XML form being edited by the user.
 * @param string $data
 *   Contains the content of the relevant XML element
 *   of the XML form after it has been edited.
 * @param string $context
 *   Required for batch processing
 * return
 *   None
 */
function presubmit_add_object_batch($newObjectPid, $rdf_relationship, $subjectPid, $data, $editFlag, $postEditSubjectTitle, $subjectDCTitle, $data) {
  module_load_include('inc', 'fedora_repository', 'api/tuque');
  module_load_include('inc', 'fedora_repository', 'ObjectHelper');
  module_load_include('inc', 'fedora_repository', 'api/fedora_item');
  module_load_include('inc', 'islandora_content_model_forms', 'FOXML');

  $newObjectDatastreamXml = $rdf_relationship['object_datastream_xml'];
  // Add the title of the object to the new object datastream.
  if ($rdf_relationship['object_xpath_title_search']) {
    // The XML has been supplied in the sparql autocomplete form
    // by the user so should contain the relevant XML title
    // element. The "build" and "countback" arguments are therefore
    // redundant because they are only needed when the XML
    // field is not found and it has to be created.
    if (!(add_to_datastream($rdf_relationship, $newObjectDatastreamXml, $rdf_relationship['object_xpath_title_search'], 'redundant', 'redundant', $data))) {
      $context['results']['errorFlag'] = 1;
      $context['results']['currentPid'] = $newObjectPid;
    }
  }
  if ($rdf_relationship['object_xpath_date_create_search']) {
    // Add a solr-friendly-creation-date to the new object
    // datastream.
    $solrDate = sprintf("%sT%s.000Z", date("Y-m-d"), date("H:i:s"));
    // The XML has been supplied in the sparql autocomplete form
    // by the user so should contain the relevant XML creation
    // date element. The "build" and "countback" arguments are
    // therefore redundant.
    if (!(add_to_datastream($rdf_relationship, $newObjectDatastreamXml, $rdf_relationship['object_xpath_date_create_search'], 'redundant', 'redundant', $solrDate))) {
      $context['results']['errorFlag'] = 1;
      $context['results']['currentPid'] = $newObjectPid;
    }
  }
  //add $newObjectDatastreamXml as MADS datastream
  $tuque = islandora_get_tuque_connection();
  $object = $tuque->repository->constructObject($newObjectPid);
  $object->relationships->registerNamespace('mads', 'http://www.loc.gov/mads/rdf/v1#'); //SFOX
  $object->label = $data;
  $object->id = $newObjectPid;
  $object_state = $rdf_relationship['object_state'];
  $object->state = $object_state;

  $object_dsid = $rdf_relationship['object_dsid']; //MADS
  $dsid_datastream = $object->constructDatastream($object_dsid, 'X');
  $dsid_datastream->label = $object_dsid;
  $dsid_datastream->setContentFromString($newObjectDatastreamXml);
  $object->ingestDatastream($dsid_datastream);


  //add this relation fedora-model:hasModel
  $object_content_model_pid = $rdf_relationship['object_content_model_pid'];
  $object->relationships->add(FEDORA_MODEL_URI, 'hasModel', $object_content_model_pid);
  //
  //
  //add to this collection
  //$relation = 'isMemberOfCollection';

  $object_collection_pid = $rdf_relationship['object_collection_pid'];
  $object->relationships->registerNamespace('fedora', FEDORA_RELS_EXT_URI);
  $object->relationships->add(FEDORA_RELS_EXT_URI, 'isMemberOfCollection', $object_collection_pid);
  $tuque->repository->ingestObject($object); //Put this object into $form_state['islandora']['objects'] so islandora_ingest_form_submitter ingests it
  //Need to add interobject links $subjectPid->$newObjectPid
  $concept = islandora_object_load($subjectPid);

  //Choose appropriate relation
  $newObjectPidns = substr($newObjectPid, 0, strpos($newObjectPid, ':'));

  switch ($newObjectPidns) {
    case 'fwltaxon': {
        $relation = 'hasTaxonomicKeyword';
        break;
      }

    default: {
        $relation = NULL;
        break;
      }
  }
  if ($relation) {
    $concept->relationships->registerNamespace('fba', FBA_URI);
    $concept->relationships->add(FBA_URI, $relation, $newObjectPid);
  }

  return $object;
}

/**
 *
 * Add a new object with the appropriate XML and RDF links
 * as a batch operation.
 * Note that $rdf_relationship and $link are not passed by
 * reference in this instance because the original arrays
 * might no longer exist by the time this batch operation
 * is called.
 *
 * @param string $newObjectPid
 *   The Persistent Identifier for the new object
 * @param array $rdf_relationship
 *   Corresponds to a single RDF-autocomplete associated with an XML-form.
 * @param string $subjectPid
 *   The Persistent Identifier for the subject object
 * @param string $data
 *   The character string entered by the user
 * @param boolean $editFlag
 *   Indicates whether the subject object is being edited.
 * @param boolean $postEditSubjectTitle
 *   Contains the title of the subject object after
 *   the XML form has been edited by the user.
 * @param string $subjectDCTitle
 *   Contains the title of the subject object prior 
 *   to the XML form being edited by the user.
 * @param string $data
 *   Contains the content of the relevant XML element
 *   of the XML form after it has been edited.
 * @param string $context
 *   Required for batch processing
 * return
 *   None
 */
function add_object_batch($newObjectPid, $rdf_relationship, $subjectPid, $data, $editFlag, $postEditSubjectTitle, $subjectDCTitle, $data) {
  module_load_include('inc', 'fedora_repository', 'api/tuque');
  module_load_include('inc', 'fedora_repository', 'ObjectHelper');
  module_load_include('inc', 'fedora_repository', 'api/fedora_item');
  module_load_include('inc', 'islandora_content_model_forms', 'FOXML');

  $newObjectDatastreamXml = $rdf_relationship['object_datastream_xml'];
  // Add the title of the object to the new object datastream.
  if ($rdf_relationship['object_xpath_title_search']) {
    // The XML has been supplied in the sparql autocomplete form
    // by the user so should contain the relevant XML title
    // element. The "build" and "countback" arguments are therefore
    // redundant because they are only needed when the XML
    // field is not found and it has to be created.
    if (!(add_to_datastream($rdf_relationship, $newObjectDatastreamXml, $rdf_relationship['object_xpath_title_search'], 'redundant', 'redundant', $data))) {
      $context['results']['errorFlag'] = 1;
      $context['results']['currentPid'] = $newObjectPid;
    }
  }
  if ($rdf_relationship['object_xpath_date_create_search']) {
    // Add a solr-friendly-creation-date to the new object
    // datastream.
    $solrDate = sprintf("%sT%s.000Z", date("Y-m-d"), date("H:i:s"));
    // The XML has been supplied in the sparql autocomplete form
    // by the user so should contain the relevant XML creation
    // date element. The "build" and "countback" arguments are
    // therefore redundant.
    if (!(add_to_datastream($rdf_relationship, $newObjectDatastreamXml, $rdf_relationship['object_xpath_date_create_search'], 'redundant', 'redundant', $solrDate))) {
      $context['results']['errorFlag'] = 1;
      $context['results']['currentPid'] = $newObjectPid;
    }
  }
  //$newObjectDoc->loadXML($newObjectDatastreamXml); //add $newObjectDatastreamXml as MADS datastream
  $tuque = islandora_get_tuque_connection();
  $object = $tuque->repository->constructObject($newObjectPid);
  $object->label = $data;
  $object->id = $newObjectPid;
  $object_state = $rdf_relationship['object_state'];
  $object->state = $object_state;

  $object_dsid = $rdf_relationship['object_dsid']; //MADS
  $object[$object_dsid]->content = $newObjectDatastreamXml;

  //add this relation fedora-model:hasModel
  $object_content_model_pid = $rdf_relationship['object_content_model_pid'];
  $object->relationships->add(FEDORA_MODEL_URI, 'hasModel', $object_content_model_pid);
  //
  //
  //add to this collection
  //$relation = 'isMemberOfCollection';

  $object_collection_pid = $rdf_relationship['object_collection_pid'];
  $object->relationships->add(FEDORA_RELS_EXT_URI, 'isMemberOfCollection', $object_collection_pid);
  //$tuque->repository->ingestObject($object); Put this object into $form_state['islandora']['objects'] so islandora_ingest_form_submitter ingests it
  $context['objectstoingest'][] = $object;
}

/**
 *
 * Remove the inverse RDF from object to subject and remove the
 * subject title from the object datastream when appropriate.
 * Note that $rdf_relationship is not passed by reference in
 * this instance because the original arrays might no longer
 * exist by the time this batch operation is called.
 *
 * @param string $subjectPid
 *   The Persistent Identifier of the subject component the RDF
 * @param string $objectPid
 *   The Persistent Identifier of the object component the RDF
 * @param array $rdf_relationship
 *   Corresponds to a single RDF-autocomplete associated with an XML-form.
 * @param string $rdfNamespace
 *   The namespace of the predicate component in the inverse RDF
 * @param string $inverseName
 *   The verb of the predicate component in the inverse RDF
 * @param int $linkTypeOutwardAndInverse
 *   Constant for link type that is subject to object and object to subject
 * @param string $context
 *   Required for batch processing
 * return
 *   None
 */
function remove_inverse_rdf_batch($subjectPid, $objectPid, $rdf_relationship, $rdfNamespace, $inverseName, $subjectDCTitle) {
  module_load_include('inc', 'fedora_repository', 'api/tuque');
  $object = islandora_object_load($objectPid);
  if ($object) {
    $object->relationships->remove($rdfNamespace, $inverseName, $subjectPid);
    // Check if inverse-object-symmetric datastream processing
    // is required.
    if ($rdf_relationship['symmetry_in_object_datastream_required'] && strlen($rdf_relationship['object_xpath_data_search']) > 0) {
      remove_from_datastream($rdf_relationship, $objectPid, $rdf_relationship['object_xpath_data_search'], $rdf_relationship['object_xpath_data_build_countback'], $subjectDCTitle);
    }
  }
  else {
    $context['results']['errorFlag'] = 1;
    $context['results']['currentPid'] = $subjectPid;
  }
}

/**
 *
 * Replace the data in an xml element of a datastream as a
 * batch operation.
 * Note that $rdf_relationship and $link are not passed by
 * reference in this instance because the original arrays
 * might no longer exist by the time this batch operation
 * is called.
 *
 * @param array $rdf_relationship
 *   Corresponds to a single RDF-autocomplete associated with an XML-form.
 * @param string $objectPid
 *   The Persistent Identifier of the object in which the datastream
 *   is to be updated
 * @param string $targetData
 *   Contains the target data in the datastream
 * @param string $replacementData
 *   Contains the replacement data for the datastream
 * @param string $context
 *   Required for batch processing
 * return
 *   None
 */
function replace_text_in_datastream_batch($rdf_relationship, $objectPid, $targetData, $replacementData) {
  replace_text_in_datastream($rdf_relationship, $objectPid, $rdf_relationship['object_xpath_data_search'], $targetData, $replacementData);
}

/**
 *
 * Create RDF links between subject-objects and object-objects 
 * as a batch operation.
 * Note that $rdf_relationship and $link are not passed by
 * reference in this instance because the original arrays
 * might no longer exist by the time this batch operation
 * is called.
 *
 * @param array $rdf_relationship
 *   Corresponds to a single RDF-autocomplete associated with an XML-form.
 * @param string $subjectPid
 *   The Persistent Identifier of the subject-object in the RDF
 * @param string $objectPid
 *   The Persistent Identifier of the object-object in the RDF
 * @param string $linkData
 *   The data associatied with the subject link
 * @param string $rdfName
 *   The verb of the predicate component in the RDF
 * @param string $rdfNamespace
 *   The stem of the predicate component in the RDF
 * @param string $inverseName
 *   The verb of the predicate component in the inverse RDF
 * @param string $inversePredicate
 *   The inverse of the predicate associated with the subject-object
 * @param boolean $editFlag
 *   Indicates whether the subject-object is being edited.
 * @param string $subjectDCTitle
 *   Contains the title of the subject object prior 
 *   to the XML form being edited by the user.
 * @param string $postEditSubjectTitle
 *   Contains the title of the subject object after
 *   the XML form has been edited by the user.
 * @param int $linkTypeOutwardOnly
 *   Constant for link type that is subject to object only
 * @param int $linkTypeOutwardAndInverse
 *   Constant for link type that is subject to object and object to subject
 * @param int $linkTypeInverseOnly
 *   Constant for link type that is object to subject only
 * @param int $linkTypeLiteral
 *   Constant for link type that is subject only
 * @param string $context
 *   Required for batch processing
 * return
 *   None
 */
function presubmit_create_rdf_links_batch($rdf_relationship, $subjectPid, $objectPid, $linkData, $rdfName, $rdfNamespace, $inverseName, $inversePredicate, $editFlag, $subjectDCTitle, $postEditSubjectTitle, $linkTypeOutwardOnly, $linkTypeOutwardAndInverse, $linkTypeInverseOnly, $linkTypeLiteral) {
  module_load_include('inc', 'fedora_repository', 'api/tuque');

  // Even when creating a new subject-object, the user could have
  // added identical entries in multiple fields, so check whether
  // a link to this object already exists.

  if ($rdf_relationship['link_type'] == $linkTypeOutwardOnly || $rdf_relationship['link_type'] == $linkTypeOutwardAndInverse) {
    $spoSubject = '<info:fedora/' . $subjectPid . '>';
    $spoPredicate = '<' . $rdf_relationship['rdf_predicate'] . '>';
    $spoObject = '<info:fedora/' . $objectPid . '>';
  }
  elseif ($rdf_relationship['link_type'] == $linkTypeLiteral) {
    $spoSubject = '<info:fedora/' . $subjectPid . '>';
    $spoPredicate = '<' . $rdf_relationship['rdf_predicate'] . '>';
    $spoObject = '"' . $linkData . '"';
  }
  else {
    // It must be an inverse-only type of link.
    $spoSubject = '<info:fedora/' . $objectPid . '>';
    $spoPredicate = '<' . $inversePredicate . '>';
    $spoObject = '<info:fedora/' . $subjectPid . '>';
  }
  $existingObjectTriple = spo_search($spoSubject, $spoPredicate, $spoObject);
  if (count($existingObjectTriple) == 0) {
    if ($rdf_relationship['link_type'] == $linkTypeOutwardOnly || $rdf_relationship['link_type'] == $linkTypeOutwardAndInverse) {
      // Add a subject-to-object RDF.
      $relationships[] = array($subjectPid, $rdfNamespace, $rdfName, $objectPid, NULL); //null to pad array to constant size
    }
    elseif ($rdf_relationship['link_type'] == $linkTypeLiteral && (strlen($linkData) > 0)) {
      // Add a literal RDF to the subject.
      $relationships[] = array($subjectPid, $rdfNamespace, $rdfName, $linkData, RELS_TYPE_PLAIN_LITERAL);
    }
    if ($rdf_relationship['link_type'] == $linkTypeOutwardAndInverse || $rdf_relationship['link_type'] == $linkTypeInverseOnly) {
      // Add an object-to-subject RDF.
      $relationships[] = array($objectPid, $rdfNamespace, $inverseName, $subjectPid, NULL); //null to pad array to constant size
      // Check if symmetric object datastream processing
      // is required.
      if ($rdf_relationship['symmetry_in_object_datastream_required'] && strlen($rdf_relationship['object_xpath_data_search']) > 0) {
        $objectDatastreamID = $rdf_relationship['object_dsid'];
        $object = islandora_object_load($subjectPid); //SFOX
        if ($object) { //vocab term might not exist yet
          $objectDatastream = $object[$objectDatastreamID];
          $objectDatastreamXml = $objectDatastream->content;
          if (!(add_to_datastream($rdf_relationship, $objectDatastreamXml, $rdf_relationship['object_xpath_data_search'], $rdf_relationship['object_xpath_data_build'], $rdf_relationship['object_xpath_data_build_countback'], $editFlag ? $postEditSubjectTitle : $subjectDCTitle))) {
            $context['results']['currentPid'] = $subjectPid;
            $context['results']['errorFlag'] = 1;
          }
          // Update the datastream with the xml containing the added node.
          $objectDatastream->content = $objectDatastreamXml;
        }
      }
    }
  }
  return $relationships;
}

/**
 *
 * Create RDF links between subject-objects and object-objects 
 * as a batch operation.
 * Note that $rdf_relationship and $link are not passed by
 * reference in this instance because the original arrays
 * might no longer exist by the time this batch operation
 * is called.
 *
 * @param array $rdf_relationship
 *   Corresponds to a single RDF-autocomplete associated with an XML-form.
 * @param string $subjectPid
 *   The Persistent Identifier of the subject-object in the RDF
 * @param string $objectPid
 *   The Persistent Identifier of the object-object in the RDF
 * @param string $linkData
 *   The data associatied with the subject link
 * @param string $rdfName
 *   The verb of the predicate component in the RDF
 * @param string $rdfNamespace
 *   The stem of the predicate component in the RDF
 * @param string $inverseName
 *   The verb of the predicate component in the inverse RDF
 * @param string $inversePredicate
 *   The inverse of the predicate associated with the subject-object
 * @param boolean $editFlag
 *   Indicates whether the subject-object is being edited.
 * @param string $subjectDCTitle
 *   Contains the title of the subject object prior 
 *   to the XML form being edited by the user.
 * @param string $postEditSubjectTitle
 *   Contains the title of the subject object after
 *   the XML form has been edited by the user.
 * @param int $linkTypeOutwardOnly
 *   Constant for link type that is subject to object only
 * @param int $linkTypeOutwardAndInverse
 *   Constant for link type that is subject to object and object to subject
 * @param int $linkTypeInverseOnly
 *   Constant for link type that is object to subject only
 * @param int $linkTypeLiteral
 *   Constant for link type that is subject only
 * @param string $context
 *   Required for batch processing
 * return
 *   None
 */
function create_rdf_links_batch($rdf_relationship, $subjectPid, $objectPid, $linkData, $rdfName, $rdfNamespace, $inverseName, $inversePredicate, $editFlag, $subjectDCTitle, $postEditSubjectTitle, $linkTypeOutwardOnly, $linkTypeOutwardAndInverse, $linkTypeInverseOnly, $linkTypeLiteral) {
  module_load_include('inc', 'fedora_repository', 'api/tuque');

  $subject = islandora_object_load($subjectPid);
  if ($subject) {
    // Even when creating a new subject-object, the user could have
    // added identical entries in multiple fields, so check whether
    // a link to this object already exists.

    if ($rdf_relationship['link_type'] == $linkTypeOutwardOnly || $rdf_relationship['link_type'] == $linkTypeOutwardAndInverse) {
      $spoSubject = '<info:fedora/' . $subjectPid . '>';
      $spoPredicate = '<' . $rdf_relationship['rdf_predicate'] . '>';
      $spoObject = '<info:fedora/' . $objectPid . '>';
    }
    elseif ($rdf_relationship['link_type'] == $linkTypeLiteral) {
      $spoSubject = '<info:fedora/' . $subjectPid . '>';
      $spoPredicate = '<' . $rdf_relationship['rdf_predicate'] . '>';
      $spoObject = '"' . $linkData . '"';
    }
    else {
      // It must be an inverse-only type of link.
      $spoSubject = '<info:fedora/' . $objectPid . '>';
      $spoPredicate = '<' . $inversePredicate . '>';
      $spoObject = '<info:fedora/' . $subjectPid . '>';
    }
    $existingObjectTriple = spo_search($spoSubject, $spoPredicate, $spoObject);
    if (count($existingObjectTriple) == 0) {
      $subject->relationships->registerNamespace('mads', 'http://www.loc.gov/mads/rdf/v1#'); //SFOX
      if ($rdf_relationship['link_type'] == $linkTypeOutwardOnly || $rdf_relationship['link_type'] == $linkTypeOutwardAndInverse) {
        // Add a subject-to-object RDF.
        $subject->relationships->add($rdfNamespace, $rdfName, $objectPid);
      }
      elseif ($rdf_relationship['link_type'] == $linkTypeLiteral && (strlen($linkData) > 0)) {
        // Add a literal RDF to the subject.
        $subject->relationships->add($rdfNamespace, $rdfName, $linkData, RELS_TYPE_PLAIN_LITERAL);
      }
      if ($rdf_relationship['link_type'] == $linkTypeOutwardAndInverse || $rdf_relationship['link_type'] == $linkTypeInverseOnly) {
        $object = islandora_object_load($objectPid);
        if ($object) {
          // Add an object-to-subject RDF.
          $object->relationships->add($rdfNamespace, $inverseName, $subjectPid);
          // Check if symmetric object datastream processing
          // is required.
          if ($rdf_relationship['symmetry_in_object_datastream_required'] && strlen($rdf_relationship['object_xpath_data_search']) > 0) {
            $objectDatastreamID = $rdf_relationship['object_dsid'];
            $objectDatastream = $object[$objectDatastreamID];
            $objectDatastreamXml = $objectDatastream->content;
            if (!(add_to_datastream($rdf_relationship, $objectDatastreamXml, $rdf_relationship['object_xpath_data_search'], $rdf_relationship['object_xpath_data_build'], $rdf_relationship['object_xpath_data_build_countback'], $editFlag ? $postEditSubjectTitle : $subjectDCTitle))) {
              $context['results']['currentPid'] = $subjectPid;
              $context['results']['errorFlag'] = 1;
            }
            // Update the datastream with the xml containing the added node.
            $objectDatastream->content = $objectDatastreamXml;
          }
        }
        else {
          $context['results']['currentPid'] = $subjectPid;
          $context['results']['errorFlag'] = 1;
        }
      }
    }
  }
  else {
    $context['results']['currentPid'] = $subjectPid;
    $context['results']['errorFlag'] = 1;
  }
}

/**
 *
 * The batch processing of RDF links and datastream updates
 * involving subject-objects and object-objects that is
 * required as a result of an edit operation being performed.
 * Note that $rdf_relationship and $link are not passed by
 * reference in this instance because the original arrays
 * might no longer exist by the time this batch operation
 * is called.
 *
 * @param array $rdf_relationship
 *   Corresponds to a single RDF-autocomplete associated with an XML-form.
 * @param int $rdfRelationshipRdfLinkTot
 *   The number of links associated with the relationship
 * @param string $subjectPid
 *   The Persistent Identifier of the subject-object in the RDF
 * @param string $objectPid
 *   The Persistent Identifier of the object-object in the RDF
 * @param string $rdfName
 *   The verb of the predicate component in the RDF
 * @param string $rdfNamespace
 *   The stem of the predicate component in the RDF
 * @param string $inverseName
 *   The verb of the predicate component in the inverse RDF
 * @param string $inversePredicate
 *   The inverse of the predicate associated with the subject-object
 * @param boolean $editFlag
 *   Indicates whether the subject-object is being edited.
 * @param string $subjectDCTitle
 *   Contains the title of the subject object prior 
 *   to the XML form being edited by the user.
 * @param string $postEditSubjectTitle
 *   Contains the title of the subject object after
 *   the XML form has been edited by the user.
 * @param int $linkTypeOutwardOnly
 *   Constant for link type that is subject to object only
 * @param int $linkTypeOutwardAndInverse
 *   Constant for link type that is subject to object and object to subject
 * @param int $linkTypeInverseOnly
 *   Constant for link type that is object to subject only
 * @param int $linkTypeLiteral
 *   Constant for link type that is subject only
 * @param string $context
 *   Required for batch processing
 * return 
 *   None
 */
function process_edit_batch($rdf_relationship, $rdfRelationshipRdfLinkTot, $subjectPid, $rdfName, $rdfNamespace, $inverseName, $inversePredicate, $preEditObjectTripleForRelationship, $replaceSubjectTitleInObjectDatastream, $preEditSubjectTitle, $postEditSubjectTitle, $linkTypeOutwardOnly, $linkTypeOutwardAndInverse, $linkTypeInverseOnly, $linkTypeLiteral) {
  module_load_include('inc', 'fedora_repository', 'api/tuque');

  $subject = islandora_object_load($subjectPid);
  if ($subject) {
    if ($rdf_relationship['link_type'] == $linkTypeOutwardOnly || $rdf_relationship['link_type'] == $linkTypeOutwardAndInverse || $rdf_relationship['link_type'] == $linkTypeLiteral) {
      $preEditPid = $preEditObjectTripleForRelationship['objectPid'];
    }
    else {
      $preEditPid = $preEditObjectTripleForRelationship['subjectPid'];
    }
    if (strlen($rdf_relationship['subject_xpath_data_search']) > 0) {
      // Check whether entries relating to this link have been
      // removed during the edit.
      $preEditMatchFound = false;
      if ($rdfRelationshipRdfLinkTot > 0) {
        foreach ($rdf_relationship['rdf_link'] as $postEditLink) {
          // Note that for a $linkTypeLiteral, the following
          // comparison is between data strings rather
          // than pids.
          if (!strcmp($preEditPid, $postEditLink['pid'])) {
            $preEditMatchFound = true;
            break;
          }
        }
      }
      if (!$preEditMatchFound) {
        if ($rdf_relationship['link_type'] == $linkTypeLiteral) {
          $subject->relationships->remove($rdfNamespace, $rdfName, $preEditPid, RELS_TYPE_PLAIN_LITERAL);
        }
        else {
          // The current $preEditPid for the object is not present
          // in the array of links that are required post-edit, so
          // unwind any links and datastream entries that are
          // associated with the object.
          $preEditObject = islandora_object_load($preEditPid);
          if ($preEditObject) {
            if ($rdf_relationship['link_type'] != $linkTypeInverseOnly) {
              $subject->relationships->remove($rdfNamespace, $rdfName, $preEditObject);
            }
            if ($rdf_relationship['link_type'] == $linkTypeOutwardAndInverse || $rdf_relationship['link_type'] == $linkTypeInverseOnly) {
              $preEditObject->relationships->remove($rdfNamespace, $inverseName, $subject);
            }
            // Check if inverse-object-symmetric link processing
            // is involved.
            if ($rdf_relationship['symmetry_in_object_datastream_required'] && strlen($rdf_relationship['object_xpath_data_search']) > 0) {
              remove_from_datastream($rdf_relationship, $preEditPid, $rdf_relationship['object_xpath_data_search'], $rdf_relationship['object_xpath_data_build_countback'], $preEditSubjectTitle);
            }
          }
          else {
            $context['results']['errorFlag'] = 1;
            $context['results']['currentPid'] = $subjectPid;
          }
        }
      }
    }
    else {
      if ($rdf_relationship['link_type'] != $linkTypeLiteral) {
        if ($replaceSubjectTitleInObjectDatastream && $rdf_relationship['symmetry_in_object_datastream_required']) {
          // There is no xml field for the object-title associated with
          // this link for the subject-object so there is no checking
          // to be done regarding pre-edit versus post-edit existence.
          // Therefore the subject-title should be updated where it 
          // appears in the datastream of the linked object. An example
          // of such a scenario would be when the title of a
          // keyword-subject-object is modified and the catalogue records
          // that point to it to have their keyword entries updated.
          replace_text_in_datastream($rdf_relationship, $preEditPid, $rdf_relationship['object_xpath_data_search'], $preEditSubjectTitle, $postEditSubjectTitle);
        }
      }
    }
  }
  else {
    $context['results']['errorFlag'] = 1;
    $context['results']['currentPid'] = $subjectPid;
  }
}

/**
 * The final function called by the drupal batch processing
 * functionality.
 * @return
 *   None
 */
function completeObjectLinkerBatchProcessing($success, $results, $operations) {
  if (count($results) > 0) {
    if ($results['errorFlag'] == 1) {
      $msg = 'A linking error occurred while processing the object with the ID ' . $results['currentPid'];
      drupal_set_message(t($msg));
    }
  }
  if (array_key_exists('msg', $results)) {
    drupal_set_message($results['msg']);
  }
}

function submit_uploaded_files($form, &$form_state) {
  module_load_include('inc', 'fedora_repository', 'api/fedora_item');
  module_load_include('inc', 'fedora_repository', 'ObjectHelper');
  module_load_include('inc', 'islandora_content_model_forms', 'ObjectLinker');

  // File is a CSV, held in the OBJ datastream - can start to process it
  // Set files to form_state, to process when form is submitted.
  $pid = $form_state['build_info']['args'][0]['objects'][0]->id;
  if (!$pid) {
    $pid = $form['#parameters']['2']; //SFOX required for the sidora adding new csv workflow
  }
  $repo_object = islandora_object_load($pid);
  create_datacomponent_datastreams($pid);

  // 7. SFOX Generate TN datastream
  $datastream_id = 'TN';
  $tn_datastream = $repo_object->constructDatastream($datastream_id, 'X');
  $tn_datastream->label = 'Thumbnail';
  $tn_datastream->mimetype = 'image/png';
  $module_path = drupal_get_path('module', 'sidora');
  $tnfile = $module_path . '/includes/fbasidora/notebook-pencil.png'; //SFOX nasty path creation hack!
  $tn_datastream->setContentFromFile($tnfile, FALSE);
  // $repo_object->ingestDatastream($tn_datastream); SFOX . THIS BREAKS 
  //add relext to new object, isMemberOfCollection -> private user collection
  $user_id = sidora_get_user_object();
  $usercollectionns = str_replace(array('-', ':'), '', $user_id);
  $usercollection = $usercollectionns . ':collection';
  $repo_object->relationships->add(FEDORA_RELS_EXT_URI, 'isMemberOfCollection', $usercollection);

  return;
}

/*
 * This function (as opposed to the repair function) doesn't recreate the COLS 
 *  datastreams for existing OBJ datastreams, or redoes the rels int links
 */

function create_datacomponent_datastreams($pid) {
  //module_load_include('module', 'tuque_wrapper', 'tuque_wrapper');
  module_load_include('inc', 'fba_sidora', 'fba_mysql');

  $repository = islandora_get_tuque_connection()->repository;
  $repo_object = islandora_object_load($pid);
  $colsds_content = array(); //array of column datastreams for later ingestion
  foreach ($repo_object as $datastream) {
    $dsids[] = $datastream->id;
  }
  foreach ($dsids as $dsid) {
    $dsidprefix = substr($dsid, 0, 3);

    if (strcmp($dsidprefix, 'OBJ') === 0) { //starts with OBJ
      //if the matching COLS datastream exists, then don't recreate it
      //Assumption, if one COLS exists, then the full amount of COLS datastreams do too.
      $dsidnumber = substr($dsid, 3); //just get the datastream number (e.g. ignoring the 'OBJ' bit)
      $colsexist = count(preg_grep('/^COLS' . $dsidnumber . '-/', $dsids));

      if ($colsexist === 0) {
        //The COLS datastreams don't exist, so it's ok to create them
        $objdatastream = $repository->api->a->getDatastreamDissemination($repo_object->id, $dsid, NULL); // Work around for bug in Tuque API: ISLANDORA-752
        // Processing First Row of CSV file (user defined headers)
        // Extract to an array containing each header


        $headers = trim_array_values(explode(",", strtok($objdatastream, "\n")));
        // Processing Second Row of CSV files (vocab terms)
        // Extract to an array containing each vocab_term then convert to DTC vocab pid
        $vocab_terms = trim_array_values(explode(",", strtok("\n")));
        // NB TODO replace the use of explode() with fgetcsv (in case cells have commas in them)

        for ($i = 0, $j = count($vocab_terms); $i < $j; $i++) {
          $term = trim($vocab_terms[$i]);
          // CSV file has already been validated using the check_vocab_term function, so
          // a vocab pid will be returned for each element in vocab_terms
          $vocab_terms_pids[$i] = _check_vocab_term($term);
        }

        // Processing Third Row of CSV files (units)
        // Extract the third row information into an array
        // This can contain Unit: and Taxon: and these are delimited by ~~ 
        // (possibly with whitespace before/after)
        $units = trim_array_values(explode(",", strtok("\n")));
        foreach ($units as $key => $unitterm) {
          $termarray = explode('~~', $unitterm);
          $unitcount[$fileindex][$key] = 0;
          foreach ($termarray as $termarrayvalue) {
            $colonpos = strpos($termarrayvalue, ':');
            $termprefix = trim(substr($termarrayvalue, 0, $colonpos));
            switch ($termprefix) {
              case 'Units': {
                  $unitcount[$fileindex][$key] ++;
                  $termvalue = trim(substr($termarrayvalue, $colonpos + 1));
                  //N/A is a valid unit but isn't in the vocabulary
                  if (strcmp($termvalue, 'N/A') === 0) {
                    //$checked_unit_result = 'N/A';
                    $units[$key] = 'N/A';
                  }
                  else {
                    //$checked_unit_result = _check_vocab_term(&$termvalue);
                    $unit = _get_units($termvalue);
                    $units[$key] = _check_vocab_term($unit);
                  }

                  /*
                    if ($checked_unit_result === NULL) {
                    $invalid_unit_term_found[$fileindex] = true;
                    $invalid_unit_terms[$fileindex][$key] = $termvalue;
                    }
                    else {
                    $valid_unit_terms[$fileindex][$key] = $termvalue;
                    } */
                  break;
                }
              case 'Taxon': {
                  $taxonvalue = trim(substr($termarrayvalue, $colonpos + 1));
                  $taxon = _get_taxon($taxonvalue);
                  $checkedtaxonterm = _check_taxon_term($taxon);
                  if (is_null($checkedtaxonterm)) {
                    //Need to create an object for this as it doesn't yet exist
                    $scientificName = $taxonvalue;
                    $namespace = 'fwltaxon';
                    $collection_pid = 'info:fedora/' . $namespace . ':collection';
                    //$nextavailablepid = fedora_item::get_next_PID_in_namespace($namespace);
                    $ingestobject = islandora_object_load($pid);
                    $nextavailablepid = $ingestobject->repository->getNextIdentifier($namespace, variable_get('islandora_basic_collection_generate_uuid', FALSE));
                    $tuque = islandora_get_tuque_connection();
                    $object = $tuque->repository->constructObject($nextavailablepid);
                    $object->relationships->registerNamespace('mads', 'http://www.loc.gov/mads/rdf/v1#'); //SFOX
                    $object->label = $scientificName;
                    $object->id = $nextavailablepid;
                    $object->state = 'A';
                    $object->relationships->add(FEDORA_RELS_EXT_URI, 'isMemberOfCollection', $collection_pid);
                    $object->relationships->add(FEDORA_MODEL_URI, 'hasModel', 'fba:taxon_cmodel');
                    $dwcdsid = 'DWC';
                    $UTCdateformatstring = 'Y-m-d\TH:i:s'; // need to append '.\000Z';                                    
                    $reccreDateTime = new DateTime();
                    //Translate to YYYY-MM-DDTHH:MM:SS.uuuZ
                    $reccresolrDateTime = $reccreDateTime->format($UTCdateformatstring) . '.000Z';

                    // PHP tries to be clever if it detects http colon slash slash in a string so it
                    // it necessary to break up the namespacing into segments.
                    $DWC1 = '<DarwinRecordSet xmlns="ht' .
                        'tp://rs.tdwg.org/dwc/dwcrecord" xmlns:dcterms="ht' .
                        'tp://purl.org/dc/terms/" xmlns:dwr="ht' .
                        'tp://rs.tdwg.org/dwc/dwcrecord" xmlns:xsi="ht' .
                        'tp://www.w3.org/2001/XMLSchema-instance" xmlns:dwc="ht' .
                        'tp://rs.tdwg.org/dwc/terms/">';

                    $DWC2 = sprintf('<dwc:Taxon><dwc:taxonID></dwc:taxonID><dwc:parentNameUsage></dwc:parentNameUsage><dwc:parentNameUsageID></dwc:parentNameUsageID><dwc:taxonRank></dwc:taxonRank><dwc:scientificName>%s</dwc:scientificName><dwc:scientificNameAuthorship></dwc:scientificNameAuthorship><dwc:namePublishedIn></dwc:namePublishedIn><dwc:nomenclaturalCode></dwc:nomenclaturalCode><dwc:taxonomicStatus></dwc:taxonomicStatus><dwc:vernacularName></dwc:vernacularName><dwc:acceptedNameUsage></dwc:acceptedNameUsage><dwc:acceptedNameUsageID></dwc:acceptedNameUsageID><dwc:originalNameUsage></dwc:originalNameUsage><dwc:originalNameUsageID></dwc:originalNameUsageID><dwc:taxonRemarks>unverified</dwc:taxonRemarks><dcterms:modified>%s</dcterms:modified></dwc:Taxon></DarwinRecordSet>', $scientificName, $reccresolrDateTime);

                    $DWCDatastream = $DWC1 . $DWC2;

                    //need to convert the date formats from 2013-03-12 to 2013-03-12T00:00:00.000Z
                    //$item->add_datastream_from_string($DWCDatastream, $dwcdsid, 'DWC Record', 'text/xml', 'X');
                    $dsid_datastream = $object->constructDatastream($dwcdsid, 'X');
                    $dsid_datastream->label = $dwcdsid;
                    $dsid_datastream->setContentFromString($DWCDatastream);
                    $object->ingestDatastream($dsid_datastream);
                    /*
                      $proc = new XsltProcessor();
                      $xsl = new DomDocument();
                      $path = drupal_get_path('module', 'sidora');
                      $xsl->load($path . '/workbench/transforms/dwc_taxon_to_dc.xsl');
                      $input = new DomDocument();
                      $input->loadXML(trim($DWCDatastream));
                      $proc->importStylesheet($xsl);
                      $newdom = $proc->transformToDoc($input);
                      $dc_xml = $newdom->saveXML();
                     */
                    $doc = new DOMDocument();
                    $proc = new XSLTProcessor();
                    $xsl_file = 'dwc_taxon_to_dc.xsl';
                    $xsl_string = sidora_xsl_string($xsl_file);
                    $doc->loadXML($xsl_string);
                    $proc->importStyleSheet($doc);
                    $xml = trim($DWCDatastream);
                    if (strpos($xml, "<?xml version") === FALSE) {
                      $docToLoad = ('<?xml version="1.0" encoding="UTF-8"?' . '>' . $xml);
                    }
                    else {
                      $docToLoad = $xml;
                    }
                    $doc->loadXML($docToLoad);
                    $dc_xml = $proc->transformToXML($doc);

                    $dc_datastream = $object->constructDatastream('DC', 'X');
                    $dc_datastream->label = 'DC';
                    $dc_datastream->setContentFromString($dc_xml);
                    $object->ingestDatastream($dc_datastream);

                    //$item->add_datastream_from_string($dc_xml, 'DC', 'DC', 'text/xml', 'X');
                    $taxa[$key][] = 'info:fedora/' . $object->id;
                  }
                  else {
                    //$cttxml = $checkedtaxonterm->asXML();
                    //$taxa[$key][] = substr($cttxml, strpos($cttxml, '"') + 1, -1);
                    $taxa[$key][] = $checkedtaxonterm;
                  }
                  break;
                }
              default: {
                  break;
                }
            }
          }
          //put some flag in here about valid csv?
        }
        $numberofcolumns = count($headers);
        //Use a mysql temporary table, as memory isn't big enough for huge arrays
        $current_row = explode(",", strtok("\n"));
        //$data_array = new SplFixedArray($arraysize);

        $ret = fba_create_temp_dataset_mysql_table($numberofcolumns, $pid);
        //$data_array = array();
        //$rowcount = 0;
        while (count($current_row) > 1 && $current_row[0] !== NULL) {
          // add new data to the data array
          fba_write_temp_dataset_mysql_table($current_row, $numberofcolumns, $pid);
          //$data_array[$rowcount] = $current_row;
          $current_row = explode(",", strtok("\n"));
          //$rowcount++;
        }

        // 5. Generate COLSn-n datastream [see later functions]
        for ($colindex = 0; $colindex < $numberofcolumns; $colindex++) {
          $coldsname = 'COLS' . $dsidnumber . '-' . ($colindex + 1); //+1 as loop starts at 0
          $paramvocabtermpid = $paramunit = $paramtaxa = NULL;
          $paramheader = $headers[$colindex];
          if ($vocab_terms_pids[$colindex]) {
            $paramvocabtermpid = (string) $vocab_terms_pids[$colindex];
          }
          if ($units[$colindex]) {
            $paramunit = (string) $units[$colindex];
          }
          if ($taxa[$colindex]) {
            $paramtaxa = $taxa[$colindex];
          }
          $colsds_content[$coldsname] = _create_column_datastream($colindex, $paramheader, $paramvocabtermpid, $paramunit, $paramtaxa, $pid, $dsid, $numberofcolumns);
        }
        //create the COLSxx-y datastreams and the RELS-INT links for the new OBJxx datastream
        $objsrelations = $repo_object->relationships;
        $objintrelations = $repo_object[$dsid]->relationships;
        foreach ($colsds_content as $columnname => $colds) {
          $cols_datastream = _create_datastream($repo_object, $columnname, 'X', 'Fedora Internal Relationships file for this object', 'application/rdf+xml', $colds->asXML());
          $repo_object->ingestDatastream($cols_datastream);
          $objintrelations->add('info:fedora/fedora-system:def/relations-internal#', 'hasConstituent', $pid . '/' . $columnname, RELS_TYPE_URI);
        }
      }
      unset($colsds_content);
    }
  }
  $ret = fba_drop_temp_dataset_mysql_table($pid);
}

/**
 * Checks validity of a term in the vocab row of a CSV file. Check:
 *  1. it starts with the right prefix
 *  2. it is a valid vocab term in the DTC vocabulary
 *
 * @param array $term
 *   the term being checked for validity
 * @return string vocab_pid
 * 	return the pid of the $term in the DTC vocabulary,
 * 	or NULL (if invalid term)
 */
function _check_vocab_term(&$term) {
  return _check_term($term, 'fba:vocabpref_collection');
}

/**
 * Checks validity of a term in the vocab row of a CSV file. Check:
 *  1. it starts with the right prefix
 *  2. it is a valid vocab term in the DTC vocabulary
 *
 * @param array $term
 *   the term being checked for validity
 * @return string vocab_pid
 * 	return the pid of the $term in the DTC vocabulary,
 * 	or NULL (if invalid term)
 */
function _check_taxon_term(&$term) {
  return _check_term($term, 'fwltaxon:collection');
}

/**
 * 
 * Common code refactored out of the two functions above
 * 
 * @param type $term
 * @param type $collection
 * @return type
 */
function _check_term(&$term, $collection) {
  $pid = NULL; // default to null
// Check that each term in the vocab row is a valid vocab term
  $query = 'SELECT ?s FROM <info:edu.si.fedora#ri> WHERE {
				?s <info:fedora/fedora-system:def/model#label> "' . $term . '" .
				?s <info:fedora/fedora-system:def/relations-external#isMemberOfCollection>
					<info:fedora/' . $collection . '> .
			}';
// run the query to see if current term is a vocab term.
// NB $limit is set to 1 as we only want to check whether $term exists in the vocabulary or not
// TUPLE query as we aren't interested in retrieving whole triples
  $result = _risearch($query, 'TUPLE', 1, 'Sparql');
  if (!is_null($result)) {
    $returnedURIs = _get_URI_from_Sparql_result($result);

    if (count($returnedURIs) <> 1) {
      //Remove this section of condition
    }
    else {
      //echo "<br />&nbsp;&nbsp;$term validated successfully<br />";
      $pid = $returnedURIs[0];
    }
  }

  return $pid;
}

function _get_URI_from_Sparql_result($results) {
  if (is_string($results)) {
    $returnedURIs[] = substr($results, strpos($results, '/') + 1);
  }
  else {
    //$sxl_result = simplexml_load_string($results);
    $returnedURIs = array();
    //$children = $sxl_result->results->children();
    foreach ($results as $things) {
      $returnedURIs[] = $things['s']['uri'];
    }
  }
  return $returnedURIs;
}

function _create_column_datastream($colindex, $header, $vocab_term_pid, $unit, $taxa, $pid, $dsid, $numofcols) {
  $colds = new SimpleXMLElement('<rdf:RDF 
              xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
              xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#" 
              xmlns:relsext="info:fedora/fedora-system:def/relations-external#" 
              xmlns:altrelsext="http://www.fedora.info/definitions/1/0/fedora-relsext-ontology.rdfs#"
              xmlns:fba="http://fba.org.uk/schemas/fba/fba_rdf/1.0.0/" 
              xmlns:fedora-model="info:fedora/fedora-system:def/model#"
              xmlns:dc="http://purl.org/dc/terms/"/>', NULL, FALSE, "http://www.w3.org/1999/02/22-rdf-syntax-ns#", TRUE);
  // This RDF file will have one RDF:description element, describing the CSV file.
  $desc = $colds->addChild('rdf:Description', NULL, RDF_URI);
  $uri = 'info:fedora/' . $pid . '/' . $dsid;
  $desc->addAttribute('rdf:about', $uri, RDF_URI);

  $objnumber = substr($dsid, 3); //just get the datastream number (ignoring the 'OBJ' bit)

  $desc->addChild('dc:fileFormat', 'text/csv', 'http://purl.org/dc/terms/');

// Add metadata for each column of the CSV file, as individual Constituents of the CSV file
// add link to the vocab term corresponding to that CSV column data
// (so the column dc:references that vocab term)
  $pointerToVocab = $desc->addChild('hasObservedProperty', NULL, FBA_URI);
  $pointerToVocab->addAttribute('rdf:resource', $vocab_term_pid, RDF_URI);

// column identifiers will be the CSV pid  with - and column number appended to the end
  $desc->addChild('dc:identifier', $pid . '-' . $objnumber . '-' . $colindex + 1, 'http://purl.org/dc/terms/'); //+1 as colindex starts at 0
// add the column header given in the first row of the CSV column
// (to set the value describing the column - relsext:HasDescription)
  $desc->addChild('relsext:HasDescription', $header, FEDORA_RELS_EXT_URI);

  // add reference to units being used for that column's data
  // except if the unit is 'N/A'
  if ($unit) {
    if (strcmp($unit, 'N/A') !== 0) {
      $pointerToUnit = $desc->addChild('hasUnit', NULL, FBA_URI);
      $pointerToUnit->addAttribute('rdf:resource', $unit, RDF_URI);

      //$desc->addChild('hasUnit', $unit, 'http://fba.org.uk/schemas/fba/fba_rdf/1.0.0/');
      //the vocabpref of the unit object needs putting into the line above
    }
  }
  // add reference to taxa being used for that column's data, can be multiple values
  if ($taxa) {
    foreach ($taxa as $taxon) {
      $pointerToTaxon = $desc->addChild('hasTaxon', NULL, FBA_URI);
      $pointerToTaxon->addAttribute('rdf:resource', $taxon, RDF_URI);
    }
  }

//
// data will be stored in RELSEXT as an RDF Seq object, i.e an ordered list
// Each column of data will form one Subset of data for the CSV file
  $subset = $desc->addChild('relsext:hasSubset', NULL, 'info:fedora/fedora-system:def/relations-external#');
  $seq = $subset->addChild('rdf:Seq', NULL, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#');

  // extract each datum from the relevant column of the data_array
  //now getting values from MySQL table
  $colname = 'COL' . ($colindex + 1);

  $cleanedpid = str_replace(':', '', $pid);
  $dbname = 'fba_temp_dataset_' . $cleanedpid;

  $sql = "select " . $colname . " from {" . $dbname . "};";
  $data = db_query($sql);
  // iterate through results
  while ($item = $data->fetchAssoc()) {
    $val = trim($item[$colname]);
    $seq->addChild('rdf:li', $val, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#');
  }
  //  for ($j = 0; $j < count($data_array); $j++) {
  //    $val = trim($data_array[$j][$colindex]);
  //    $seq->addChild('rdf:li', $val, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#');
  //  }
  return $colds;
}

function _create_RELS($returnedRDF, $pid, $dsid, $columnnames) {
  $objnumber = substr($dsid, 3); //just get the datastream number (ignoring the 'OBJ' bit)
// This RDF file will have one RDF:description element, describing the CSV file.
  $desc = $returnedRDF->addChild('rdf:Description', NULL, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#');
  $uri = 'info:fedora/' . $pid . '/' . $dsid;
  $desc->addAttribute('rdf:about', $uri, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#');

  $dctype = $desc->addChild('dc:type', NULL, 'http://purl.org/dc/terms/');
  $dctype->addAttribute('rdf:resource', 'dc:Dataset', 'http://www.w3.org/1999/02/22-rdf-syntax-ns#');

  $desc->addChild('dc:fileFormat', 'text/csv', 'http://purl.org/dc/terms/');

//rdf needed from pid to OBJ<n>
  foreach ($columnnames as $columnname) {
    $objconstituent = $desc->addChild('relsint:hasConstituent', NULL, 'info:fedora/fedora-system:def/relations-internal#'); //RELS_INT_URI
    $coluri = 'info:fedora/' . $pid . '/' . $columnname;
    $objconstituent->addAttribute('rdf:resource', $coluri, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#');
  }
  return $returnedRDF;
}

function trim_array_values($array) {
  foreach ($array as $key => $value) {
    $array[$key] = trim($value);
  }
  return $array;
}

/**
 * Generic risearch function.
 *
 * @param string $risearchstring
 *   actual string to be passed to risearch
 * @param string $type
 *   TUPLE (default) or TRIPLE
 * @param int $limit
 *   limit on number of results to return (default 1000) 
 * @param string $format
 *   Return format to return - see risearch documentation (no default set)
 *   TODO Set default
 *
 * @return string
 *   raw search return values
 */
function _risearch($risearchstring, $type = 'TUPLE', $limit = 1000, $format = 'Sparql') {
  module_load_include('inc', 'fedora_repository', 'api/fedora_utils');
  $returnedpids = '';
//  $offset = 0;
//  $limit = 1000;
// default value for $format, if not set, is N-Triples for $type='TRIPLE
  //$encodedquery = htmlentities(urlencode($risearchstring));
  $repository = islandora_get_tuque_connection()->repository;
  $ri = $repository->ri;
  /*
    $url = variable_get('fedora_repository_url', 'http://localhost:8080/fedora/risearch');
    if ($type == 'TRIPLE') {
    $url .= "?type=triples&flush=TRUE&format=$format&limit=$limit&lang=sparql&stream=on&query=" . $encodedquery;
    }
    else {
    $url .= "?type=tuples&flush=TRUE&format=$format&limit=$limit&lang=sparql&stream=on&query=" . $encodedquery;
    }
    $content = trim(do_curl($url)); */
  $contents = $ri->sparqlQuery($risearchstring, $limit);

  foreach ($contents as $content) {
    foreach ($content as $foundobject) {
      $returnedpids .= $foundobject['uri'] . ' ';
    }
  }
  return $returnedpids != '' ? $returnedpids : NULL;
}

/**
 * check if the $unit parameter starts with the 'Units:' prefix
 * (case insensitive)
 *  If it does, strip off this prefix, trim off any whitespace 
 *   surrounding the remaining string and return the result.
 *  If it doesn't start with this prefix, trim off any whitespace
 *   around the $unit parameter and return the result
 *
 * @param string $unit
 *   the string being checked for the 'units: prefix
 * @return string 
 * 	return the trimmed string
 */
function _get_units(&$unit) {
// 
  $prefix = strtolower(substr($unit, 0, 6));
  if (ereg("^units:", $prefix)) {
    return trim(substr($unit, 6));
  }
  else {
    return trim($unit);
  }
}

/**
 * check if the $taxon parameter starts with the 'Taxon:' prefix
 * (case insensitive)
 *  If it does, strip off this prefix, trim off any whitespace 
 *   surrounding the remaining string and return the result.
 *  If it doesn't start with this prefix, trim off any whitespace
 *   around the parameter and return the result
 *
 * @param string $taxon
 *   the string being checked for the 'taxon: prefix
 * @return string 
 * 	return the trimmed string
 */
function _get_taxon(&$taxon) {
// 
  $prefix = strtolower(substr($taxon, 0, 6));
  if (ereg("^taxon:", $prefix)) {
    return trim(substr($taxon, 6));
  }
  else {
    return trim($taxon);
  }
}

function _create_datastream(&$fedora_object, $dsid, $controlGroup = "X", $label = "New Datastream", $mimetype, $content, $from_file = false) {
  $new_datastream = $fedora_object->constructDatastream($dsid, $controlGroup);
  $new_datastream->label = $label;
  $new_datastream->mimetype = $mimetype;
  if ($from_file) {  // TODO can set a flag within the parameters for create_datastream, to indicate that it needs to set datastream content from a file rather than string (for CSV fix)
    $new_datastream->setContentFromFile($content);
  }
  else {
    $new_datastream->setContentFromString($content);
  }

  return $new_datastream;
}
